# 多线程基础

## 线程操作

### 创建和运行线程

异步调用：

需要等待结果返回，才能继续运行的就是同步。

不需要等待结果返回，就能继续运行的就是异步。

```java
//通过继承的方式，来重写run方法
class  MyThread extends Thread{
    @Override
    public void run() {
        for(int i=0;i<100;i++){
            if(i%2==0){
                System.out.println(i);
            }
        }
    }
}

//匿名类的方式比较合适
Thread thread = new Thread(){
            @Override
            public void run() {
                for(int i=0;i<100;i++){
                    if(i%2==0){
                        System.out.println(i);
                    }
                }
            }
        };
        thread.start();

//实现接口的方式
Runnable r = new Runnable() {
         @Override
         public void run() {
             for(int i=0;i<100;i++){
                 if(i%2==0){
                     System.out.println(i);
                 }
             }
         }
     } ;
     Thread thread = new Thread(r);
     thread.start();

//Lambda表达式
    Thread thread = new Thread(()->{
         for(int i=0;i<100;i++){
             if(i%2==0){
                 System.out.println(i);
             }
         }
     });
     thread.start();

```

Thread和Runnable的关系

- 第一种是把线程和任务合并在了一起，第二种是线程和任务分开了
- 用Runnable更容易和线程池等高级API配合
- 用Runnable让任务类脱离了Thread的继承体系，更灵活。

| 方法名           | static | 功能说明                                           | 注意                                                         |
| ---------------- | ------ | -------------------------------------------------- | ------------------------------------------------------------ |
| start()          |        | 启动新县城，在新的线程中运行run方法                |                                                              |
| run()            |        | 新线程启动后会调用该方法                           |                                                              |
| join()           |        | 等待线程运行结束                                   |                                                              |
| join(long n)     |        | 等待线程运行结束，最多等待n毫秒                    |                                                              |
| getId()          |        | 获取线程长整型id                                   | id唯一                                                       |
| getName()        |        | 获取线程名                                         |                                                              |
| setName(String)  |        | 修改线程名                                         |                                                              |
| getPriority()    |        | 获取线程优先级                                     |                                                              |
| setPriority(int) |        | 修改线程优先级                                     | java中规定线程优先级是1-10的整数，较大优先级能提高该线程被CPU调度的几率 |
| getState()       |        | 获取线程状态                                       | java中线程状态用6个enum表示，分别为NEW，RUNNABLE，BLOCKED，WAITING，TIMED_WAITING，TERMINATED |
| isInterrupted()  |        | 判断是否被打断                                     | 不会清除打断标记                                             |
| isAlive()        |        | 线程是否存活                                       |                                                              |
| interrupte()     |        | 打断线程                                           | 如果被打断的线程正在sleep,wait,join会导致线程抛出InterruptedExceptioon，并清除打断标记，如果打断正在运行的线程，则会设置打断标记 |
| interrupted()    | static | 判断当前线程是否被打断                             | 会清除打断标记                                               |
| currentThread()  | static | 获取当前正在执行的线程                             |                                                              |
| Sleep(long n)    | static | 让当前执行的线程休眠n毫秒，休眠时让出cpu给其他线程 |                                                              |
| yield()          | static | 提示线程调度器让出当前线程对CPU的使用              |                                                              |

- 不调用start方法，直接调用run方法也能执行，不过此时的run方法相当于普通方法，不会开辟线程。
- start方法不能被调用两次，调用第二次的时候，会抛出ILIegalThreadStateException异常

### 线程运行状态

<img src="resources/线程状态图.png" style="zoom:80%;" />

- BLOCKED，WAITING，TIMED_WAITING是线程休眠状态的三种原因

- RUNNABLE->BLOCKED,线程synchronized锁导致
- RUNNABLE->WAITING：
  1. 获synchronized隐式锁线程，调用Object.wait()方法
  2. 调用Thread.join()方法
  3. 调用LockSupport.park()方法

- RUNNABLE->TIMED_WAITING的状态转换
  1. Thread.sleep(long millis)方法
  2. 获synchronized隐式锁线程，调用Object.wait(long timeout)方法
  3. 调用带超时参数的 Thread.join(long millis) 方法
  4. 调用带超时参数的 LockSupport.parkNanos(Object blocker, long deadline) 方法；
  5. 调用带超时参数的 LockSupport.parkUntil(long deadline) 方法。

- NEW ->RUNNABLE刚创建出来的Thread对象就是NEW状态，调用start方法进入RUNNABLE状态

- RUNNABLE->TERMINATED:线程执行完run方法就自动跳到终止状态。


Q1:stop方法为什么被弃用？

​     stop会直接暴力的杀死线程，没有善后工作。如果线程持有ReentrantLock锁，没有机会调用unlock释放锁。

interrupt()方法通知线程执行后续操作。

​     如果A处在WAITING，TIMED_WAITING,调用A的interrupt()方法会使线程A回到RUNNABLE状态。同时触发InterruptedException异常。

​     如果A处在RUNNABLE状态，则需要调用isInterrupted()方法来判断是不是自己被中断了,两阶段终止。

Q2：join方法的实现原理，等待A线程结束，就A.join();

```java
public final synchronized void join(long millis)
    throws InterruptedException {
        long base = System.currentTimeMillis();
        long now = 0;

        if (millis < 0) {                                   
            throw new IllegalArgumentException("timeout value is negative");
        } 

        if (millis == 0) { 
            while (isAlive()) {                              //活着就不断的等待
                wait(0);
            }
        } else {
            while (isAlive()) {                             //等待millis秒，超出时间就不等了，或者没到时间，就结束了
                long delay = millis - now;
                if (delay <= 0) {                           //防止虚假唤醒
                    break;
                }
                wait(delay);                                
                now = System.currentTimeMillis() - base;
            }
        }
    }
```

烧水泡茶的例子

```java
      Thread a = new Thread(()->{
           System.out.println("洗水壶");
           try {
               Thread.sleep(1000);
               System.out.println("烧开水");
               Thread.sleep(5000);
           } catch (InterruptedException e) {
               e.printStackTrace();
           }
       });

       Thread b = new Thread(()->{
           System.out.println("洗茶壶");
           try {
               Thread.sleep(1000);
               System.out.println("洗茶杯");
               Thread.sleep(2000);
               a.join();
               System.out.println("泡茶");
               Thread.sleep(1000);
           } catch (InterruptedException e) {
               e.printStackTrace();
           }
       });

       a.start();
       b.start();
```

### 线程共享的问题及解决方案

```java
      Thread a = new Thread(()->{
           for(int i=0;i<5000;i++){
               counter++;
           }
       },"t1");

       Thread b = new Thread(()->{
          for(int i=0;i<5000;i++){
              counter--;
          }
       },"t2");

       a.start();
       b.start();
       a.join();
       b.join();
       System.out.println(counter);

//结果为69，并不是0
```

解决方法：

- 阻塞式：synchronized，Lock
- 非阻塞式：原子变量

```java
//加锁的解决方案，用原子变量也可以。
   public static int counter = 0;
    public static final Object room = new Object();
    public static void main(String[] args) throws InterruptedException {
       Thread a = new Thread(()->{
           for(int i=0;i<5000;i++){
               synchronized (room) {
                   counter++;
               }
           }
       },"t1");

       Thread b = new Thread(()->{
          for(int i=0;i<5000;i++){
              synchronized (room) {
                  counter--;
              }
          }
       },"t2");

        a.start();
        b.start();
        a.join();
        b.join();
        System.out.println(counter);
```

- synchronized加在普通方法上，锁住的对象是this
- synchronized加在静态方法上，锁住的对象是该类的class对象

### 变量的线程安全分析

Q1：成员变量和静态变量是否安全？

- 如果他们没有共享，则线程安全
- 如果他们被共享了，根据他们的状态是否能改变又分两种情况：
  1. 如果只有读操作，则线程安全
  2. 如果有读写操作，则这段代码是临界区，则需要考虑线程安全。

Q2: 局部变量是否安全？

- 局部变量是线程安全的

- 但是局部变量的引用则未必：

  1. 如果该对象没有逃离方法的作用访问，它是线程安全的

  2. 如果逃离了方法的作用范围，需要考虑线程安全

  ```java
  //线程不安全的例子，因为list在堆上，两个线程同时引用该变量，导致出现错误
  //如果list在method1方法内部，虽然也在堆上，但是会创建两个list，不会出现线程安全问题
  public class Test02 {
      public static void main(String[] args) {
          ThreadUnsafe test = new ThreadUnsafe();
          for(int i=0;i<2;i++){
              new Thread(()->{
                 test.method1(1000);
              }).start();
          }
      }
  }
  
  class ThreadUnsafe{
      ArrayList<String> list = new ArrayList<>();
  
      public void method1(int loopNumber){
          for(int i=0;i<loopNumber;i++){ 
              method2();
              method3();
          }
      }
  
      private void method2(){list.add("1");}
  
      private void method3(){list.remove(0);}
  }
  ```

### 常见的线程安全类

- String

- Integer

- StringBuffer

- Random

- Vector

- Hashtable

- java.util.concurrent包下的类。

线程安全是指，多个线程调用同一个实例的某个方法是线程安全的，即单个方法是原子的，但是多个方法的组合不是原子的

## Wait&Notify机制

只有拥有锁对象的调用下面的方法才不会出错，否则会报IllegalMonitorStateException异常

- obj.wait()让进入object监视器的线程到waitSet等待
- obj.notify()让object上正在waitSet等待的线程中挑一个唤醒
- obj.notifyAll()让object上正在waitSet等待的线程全部唤醒

```java
       new Thread(()->{
            System.out.println("t1进入线程");
            synchronized (lock){
                try {
                    lock.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            System.out.println("t1:我运气好，我先走了!");

        },"t1").start();

        new Thread(()->{
            System.out.println("t2进入线程");
            synchronized (lock){
                try {
                    lock.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            System.out.println("t2:我运气好，我先走了!");

        },"t2").start();



        Thread.sleep(2000);
        synchronized (lock){
            System.out.println("看看谁运气好");
            lock.notify();
        }
```

```java
//wait的正确使用方法
synchronized(lock){
	while(条件不满足){    //防止被其他线程叫醒时，条件还没满足。
		lock.wait()
	}
}
```

sleep和wait的区别

1. sleep是Thread的方法，而wait是Object的方法。

2. sleep不需要强制和synchronized配合使用，但wait需要和synchronized一起使用。

3. sleep在睡眠的时候，不会释放对象锁，但是wait在等待的时候会释放锁。

4. 他们的状态都是TIMED_WAITING

    

park和unpark 与wait notify的区别

```java
LockSupport.park()；     //暂停当前线程

LockSupport.unpark();    //恢复某个线程的运行
```

1. wait，notify和notifyAll必须配合Object Monitor一起使用，而park，unpark不必。
2. park&unpark是以线程为单位来阻塞和唤醒线程，而notify只能随机唤醒一个线程，notifyAll是唤醒所有等待的线程，就不那么精确。
3. park&unpark可以先unpark，而wait和notify不能先notify。

## ReentrantLock锁

ReentrantLock锁是可重入锁，可重入是指同一个线程如果首次获得这把锁，那么因为它是这把锁的拥有者，因此有权利再次获得这把锁。

相对于synchronized具备以下特点

- 可中断:lock.lockInterruptibly()方法
- 可设置超时时间：lock.tryLock()方法
- 可设置成公平锁
- 支持多个条件变量
- 得手动加锁和解锁

```java
reentrantLock.lock()
try{
	//临界区
}finally{
	reentrantLock.unlock()
}
```

```java
 //MESA模型的实现，synchronized是简化实现只有一个条件变量，这个实现了有多个条件变量。这样做防止了虚假唤醒。
       Condition condition1 = lock.newCondition();
        Condition condition2 = lock.newCondition();

        lock.lock();

        condition1.await();

        condition1.signal();
```

## ReentrantReadWriteLock

```java
ReentrantReadWriteLock rw = new ReentrantReadWriteLock();
//加读锁
ReentrantReadWriteLock.ReadLock r = rw.readLock();
ReentrantReadWriteLock.writeLock w = rw.writeLock();
//加读锁
r.lock()
//解除读锁  
r.unlock()

//加写锁
w.lock()
//解除写锁
w.unlock()
```

- 读锁不支持条件变量
- 重入时升级不支持：持有读锁的前提下，去持有写锁会造成等待。
- 重入时降级支持：即持有写锁的情况下去获取读锁
- 适用于读多写少的情况

```java
    private Object data;

    private ReentrantReadWriteLock rw = new ReentrantReadWriteLock();
    private ReentrantReadWriteLock.ReadLock r = rw.readLock();
    private ReentrantReadWriteLock.WriteLock w = rw.writeLock();

    public Object read(){
        System.out.println(new Date()+"  获取读锁");
        r.lock();
        try{
            System.out.println(new Date()+"  读取");
            Thread.sleep(1000);
            return data;
        }catch (InterruptedException e) {
            e.printStackTrace();
        }finally {
            System.out.println(new Date()+"  释放读锁");
            r.unlock();
        }
        return null;
    }

    public void write(){
        System.out.println(new Date()+"  获取写锁");
        w.lock();
        try {
            System.out.println(new Date()+"  写入");
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }finally {
            System.out.println(new Date()+"  释放写锁");
            w.unlock();
        }
    }

    public static void main(String[] args) {
        //可以同时读取
        Test08 a = new Test08();
        new Thread(()->{
            a.read();
        }).start();

        new Thread(()->{
            a.read();
        }).start();
        
        //只能先执行一个
        Test08 a = new Test08();
        new Thread(()->{
            a.read();
        }).start();

        new Thread(()->{
            a.write();
        }).start();
    }

```

## ThreadLocal

- ThreadLocalMap是在ThreadLocal中使⽤内部类来编写的，但对象的引⽤是在Thread中
- Thread为每个线程维护了ThreadLocalMap这么⼀个Map，⽽ThreadLocalMap的key是LocalThread对象本身，value则是要存储的对象

```java
 public void set(T var1) {
        //获取当前线程
        Thread var2 = Thread.currentThread();
        //获取ThreadLocalMap对象
        ThreadLocal.ThreadLocalMap var3 = this.getMap(var2);
        if (var3 != null) {
            //如果对象存在，将当前Thread当key，var1当值存储
            var3.set(this, var1);
        } else {
            this.createMap(var2, var1);
        }
    }

ThreadLocal.ThreadLocalMap getMap(Thread var1) {
        return var1.threadLocals;
    }

//Thread类中持有的引用
ThreadLocal.ThreadLocalMap threadLocals = null;

//继承自弱引用，垃圾回收，这个就会被回收
static class Entry extends WeakReference<ThreadLocal<?>> {
            Object value;

            Entry(ThreadLocal<?> var1, Object var2) {
                super(var1);
                this.value = var2;
            }
        }


 public T get() {
        Thread var1 = Thread.currentThread();
        ThreadLocal.ThreadLocalMap var2 = this.getMap(var1);
        if (var2 != null) {
            ThreadLocal.ThreadLocalMap.Entry var3 = var2.getEntry(this);
            if (var3 != null) {
                Object var4 = var3.value;
                return var4;
            }
        }

        return this.setInitialValue();
    }

```

![](F:/学习资料/Nodes/Java基础/多线程/resources/ThreadLocal.PNG)

在ThreadLocalMap中，entry的key是弱引用，value仍然是一个强引用。当某一条线程中的ThreadLocal使用完毕，没有强引用指向它的时候，这个key指向的对象就会被垃圾收集器回收，从而这个key就变成了null；所以entry就变成了(null, value), 而entry 和 value 都是强引用，并且只要entry还在，value就一直存在。所以如果我们不手动清理掉这些键为空的entry， 在线程执行完毕之前，这个entry就一直处于内存泄漏的状态。线程生命周期越长，内存泄漏的就越多。

## 工具类

### stampedlock

- 自JDK 8加入，是为了优化读性能，它的特点是在使用读锁、写锁的时候必须配合戳使用。

- 不支持条件变量

- 不可重入

```java
//加读锁
long stamp = lock.readLock();
lock.unlockRead(stamp);
//加写锁
long stamp = lock.writeLock();
lock.unlockWrite(stamp);
```

```java
 private int data;

    private final StampedLock lock = new StampedLock();

    public Test09(int data){
        this.data = data;
    }

    public int read(int readTime){
        long stamp = lock.tryOptimisticRead();
        System.out.println("optimistic read locking"+stamp);
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        if(lock.validate(stamp)){
            System.out.println("read finish"+stamp);
            return data;
        }

        System.out.println("updating to read lock"+stamp);
        try{
            stamp = lock.readLock();
            System.out.println("read lock"+stamp);
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println("read finish"+stamp);
            return data;
        }finally {
            System.out.println("read unlock"+stamp);
            lock.unlock(stamp);
        }
    }

    public void write(int newData){
        long stamp = lock.writeLock();
        System.out.println("write lock"+stamp);
        try {
            Thread.sleep(2000);
            this.data = newData;
        } catch (InterruptedException e) {
            e.printStackTrace();
        }finally {
            System.out.println("write unlock"+stamp);
            lock.unlockWrite(stamp);
        }
    }

    public static void main(String[] args) {
        Test09 a = new Test09(1);
        new Thread(()->{
            a.write(1);
        }).start();

        new Thread(()->{
            a.read(0);
        }).start();
    }
```

### semaphore

- 信号量，用来限制同时访问共享资源的线程上限
- 使用Semaphore限流，在访问高峰期，让请求线程阻塞，高峰期过去再释放许可，当然它只适合限制单机线程数量，并且仅是限制线程数，而不是资源数。

下面就是信号量的模型（Semaphore的原理），一共有三个方法

![](F:/学习资料/Nodes/Java基础/多线程/resources/信号量模型图.PNG)

- init()：设置计数器的初始值。
- down()：计数器的值减 1；如果此时计数器的值小于 0，则当前线程将被阻塞，否则当前线程可以继续执行。（P操作）
- up()：计数器的值加 1；如果此时计数器的值小于或者等于 0，则唤醒等待队列中的一个线程，并将其从等待队列中移除。（V操作）

下面是具体的semaphore用法

```java
        // 1. 创建 semaphore 对象
        Semaphore semaphore = new Semaphore(3);
        // 2. 10个线程同时运行
        for (int i = 0; i < 10; i++) {
            new Thread(() -> {
                // 3. 获取许可
                try {
                    semaphore.acquire();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                try {
                    System.out.println("running...");
                    Thread.sleep(1000);
                    System.out.println("end...");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    // 4. 释放许可
                    semaphore.release();
                }
            }).start();
        }
    }
```

### countdownlatch

- 用来进行线程同步协作，等待所有线程完成倒计时。
- 其中构造参数用来初始化等待计数值，await()用来等待计数归零，countDown（）让计数减一。

```java
  ExecutorService service = Executors.newFixedThreadPool(10);
        CountDownLatch latch = new CountDownLatch(10);
        Random r = new Random();
        String[] all = new String[10];
        for(int j=0;j<10;j++){
            int k = j;
            service.submit(()->{
            for(int i=0;i<=100;i++){
                try {
                    Thread.sleep(r.nextInt(100));
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                all[k] = i+"%";
                System.out.print("\r"+ Arrays.toString(all));
            }
            latch.countDown();
            });
        }
        latch.await();
        System.out.println("\n游戏开始");
        service.shutdown();
```

### cyclicbarrier

- 循环栅栏，可以重复使用计数，不用多次创建对象

```java
 ExecutorService service = Executors.newFixedThreadPool(2);
        CyclicBarrier barrier = new CyclicBarrier(2,()->{
            System.out.println("task1 task2 finish...");
        });

        for(int i=0;i<3;i++){
            service.submit(()->{
                System.out.println("task1 begin....");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            });

            service.submit(()->{
                System.out.println("task2 begin....");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            });
        }

        service.shutdown();
```



## 无锁工具-原子类

![](F:/学习资料/Nodes/Java基础/多线程/resources/原子类.png)

原子类的实现靠的是CAS操作，下面就是CAS的原理。

```java
//balance是账户余额，amount是要减少的钱
public void withdraw(Integer amount){
    while(true){
        //获得旧值
        int prev = balance.get();
        //balance没被修改的时候，希望的得到的值。
        int next = prev - amount;
        //判断是否发生了修改，发生修改了就重试，没有发生修改就返回true。
        if(balance.compareAndSet(prev,next)){
            break;
        }
    }
}
```

但是CAS会产生ABA问题，线程A想把A变成C，在变的过程中，有线程把A变成了B，又变回了A，但是前面的线程还是能把A修改成C，

可以再加一个版本号，来解决这个问题

synchronized和CAS的区别:

- CAS 是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，重试。

- synchronized 是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想

改，我改完了解开锁，你们才有机会。

CAS效率高的原因：

- 因为没有使用 synchronized，所以线程不会陷入阻塞，没有上下文切换。

- 但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响，自旋需要CPU，适合多核情况。

### 原子整数

```java
AtomicInteger i = new AtomicInteger(0);

// 获取并自增（i = 0, 结果 i = 1, 返回 0），类似于 i++
System.out.println(i.getAndIncrement());

// 自增并获取（i = 1, 结果 i = 2, 返回 2），类似于 ++i
System.out.println(i.incrementAndGet());

// 自减并获取（i = 2, 结果 i = 1, 返回 1），类似于 --i
System.out.println(i.decrementAndGet());

// 获取并自减（i = 1, 结果 i = 0, 返回 1），类似于 i--
System.out.println(i.getAndDecrement());
```

### 原子引用

AtomicStampedReference- 可以记录修改的版本号

AtomicMarkableReference-记录有没有被修改过

都能解决ABA问题。

## 不可变对象

## 线程池

线程池的好处：

- 降低资源消耗，通过重复利用已创建的线程降低线程创建和销毁造成的损耗。

- 提高响应速度，当任务到达时，任务可以不需要等到线程创建就能立即执行。

- 提高线程的可管理性。

### FixedThreadPool

```java
    public static ExecutorService newFixedThreadPool(int nThreads) {
        return new ThreadPoolExecutor(nThreads, nThreads,
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue<Runnable>());
    }
```

- 核心线程数=最大线程数，没有急救线程被创建。
- 阻塞队列是无界的，可以放任务队列
- 超时时间为0，
- 适合任务量已知，且耗时的操作

```java
 ExecutorService pool = Executors.newFixedThreadPool(2);

        pool.execute(()->{
            System.out.println("1");
        });

        pool.execute(()->{
            System.out.println("2");
        });

        pool.execute(()->{
            System.out.println("3");
        });
```

### CachedThreadPool

```java
  public static ExecutorService newCachedThreadPool() {
        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                      60L, TimeUnit.SECONDS,
                                      new SynchronousQueue<Runnable>());
    }
```

- 核心线程数是0，最大线程数是Integer.MAX_VALUE，救急线程的空闲生存时间是60s，意味着都是救急线程。
- 救急线程可以无限创建。
- SynchronousQueue实现特点是，没有容量，没有线程来取是放不进去的。
- 线程池表现为线程数会根据任务量不断增长，没有上限，当任务执行完毕，空闲1分钟后释放线程。适合任务数比较密集，但每个任务执行时间段的情况。

```java
//添加元素就会阻塞，直到数据被取走之后，才能添加下一个数据。
SynchronousQueue<Integer> integers = new SynchronousQueue<>();

        new Thread(()->{
            try{
                System.out.println("putting 1");
                integers.put(1);
                System.out.println("1 putted");

                System.out.println("putting 2");
                integers.put(2);
                System.out.println("2 putted");

            }catch (InterruptedException e){

            }
        },"t1").start();


        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }


        new Thread(()->{
            try{
                System.out.println("taking 1");
                integers.take();
            }catch (InterruptedException e){
                e.printStackTrace();
            }
        },"t2").start();

        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        new Thread(()->{
            try{
                System.out.println("taking 2");
                integers.take();
            }catch (InterruptedException e){
                e.printStackTrace();
            }
        },"t3").start();
```

```
putting 1
taking 1
1 putted
putting 2
taking 2
2 putted
```

### **SingleThreadExecutor**

```java
public static ExecutorService newSingleThreadExecutor() {
     return new FinalizableDelegatedExecutorService
             (new ThreadPoolExecutor(1, 1,
             0L, TimeUnit.MILLISECONDS,
             new LinkedBlockingQueue<Runnable>()));
}
```

- 希望多个任务排队执行。线程数固定为1，任务数多于1时，会放入无界队列排队。任务执行完毕，这唯一的线程也不会释放。

区别：

- 自己创建一个单线程串行执行任务，如果任务执行失败而终止那么没有任何补救措施，而线程池会新建一个线程，保证池的正常工作

- Executors.newSingleThreadExecutor()线程数始终为1，不能修改。

### ScheduledThreadPoolExecutor

```java
  ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);
        System.out.println("开始执行时间"+new Date());
        executor.schedule(()->{
            System.out.println("任务1，执行时间"+new Date());
            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        },1000, TimeUnit.MILLISECONDS);

        executor.schedule(()->{
            System.out.println("任务2，执行时间"+new Date());
            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        },1000, TimeUnit.MILLISECONDS);
```

```
开始执行时间Sat Sep 26 11:09:34 GMT+08:00 2020
任务1，执行时间Sat Sep 26 11:09:35 GMT+08:00 2020
任务2，执行时间Sat Sep 26 11:09:37 GMT+08:00 2020
```

```java
//本来应该隔一秒执行一次，但是任务执行时间为2s，所以间隔2s执行
ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);
        System.out.println("开始执行时间"+new Date());
        executor.scheduleAtFixedRate(()->{
            System.out.println("任务，执行时间"+new Date());
            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        },1000, 1000,TimeUnit.MILLISECONDS);

```

```
开始执行时间Sat Sep 26 11:11:39 GMT+08:00 2020
任务，执行时间Sat Sep 26 11:11:40 GMT+08:00 2020
任务，执行时间Sat Sep 26 11:11:42 GMT+08:00 2020
任务，执行时间Sat Sep 26 11:11:44 GMT+08:00 2020
任务，执行时间Sat Sep 26 11:11:46 GMT+08:00 2020
```

```java
//不管线程执行时间，都延时1s
ScheduledExecutorService executor = Executors.newScheduledThreadPool(2);
        System.out.println("开始执行时间"+new Date());
        executor.scheduleWithFixedDelay(()->{
            System.out.println("任务，执行时间"+new Date());
            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        },1000, 1000,TimeUnit.MILLISECONDS);

```

```
开始执行时间Sat Sep 26 11:14:13 GMT+08:00 2020
任务，执行时间Sat Sep 26 11:14:14 GMT+08:00 2020
任务，执行时间Sat Sep 26 11:14:17 GMT+08:00 2020
任务，执行时间Sat Sep 26 11:14:20 GMT+08:00 2020
任务，执行时间Sat Sep 26 11:14:23 GMT+08:00 2020
```



### 向线程池提交任务

```java
// 执行任务
void execute(Runnable command);

// 提交任务 task，用返回值 Future 获得任务执行结果
<T> Future<T> submit(Callable<T> task);

// 提交 tasks 中所有任务
<T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)
 throws InterruptedException;

// 提交 tasks 中所有任务，带超时时间
<T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks,
 long timeout, TimeUnit unit)
 throws InterruptedException;

// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消
<T> T invokeAny(Collection<? extends Callable<T>> tasks)
 throws InterruptedException, ExecutionException;


// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消，带超时时间
<T> T invokeAny(Collection<? extends Callable<T>> tasks,
 long timeout, TimeUnit unit)
 throws InterruptedException, ExecutionException, TimeoutException;
```

### 关闭线程池

```java
/*
线程池状态变为 SHUTDOWN
- 不会接收新任务
- 但已提交任务会执行完
- 此方法不会阻塞调用线程的执行
*/
void shutdown();



/*
线程池状态变为 STOP
- 不会接收新任务
- 会将队列中的任务返回
- 并用 interrupt 的方式中断正在执行的任务
*/
List<Runnable> shutdownNow();
```

# 多线程进阶

##  Java内存模型(JMM)

### Java并发解决的三个问题

- **可见性**-保证指令不会受cpu缓存的影响

```java
//加锁的时候会导致可见性，println是加锁的，所以while里面加了输出就会同步，
//用来解释可见性的问题，
   static volatile boolean run = true;

    public static void main(String[] args) throws InterruptedException {
        Thread t =new Thread(()->{
            while(run){
            }
        });
        t.start();

        Thread.sleep(1000);
        System.out.println("停止");
        run = false;
    }
```

<img src="F:/学习资料/Nodes/Java基础/多线程/resources/JMM示意图.PNG" style="zoom:50%;" />

如上图所示，为JMM内存模型，每一个线程都有自己的工作内存，这里保存了变量的副本，所有的修改操作都是在工作内存中完成后，刷新到主内存，内存之间的通信也是通过主内存进行的。由于上面的原因导致了可见性的问题。

- **有序性**-保证指令不会受cpu指令并行优化的影响

```java
/*
可能出现的情况
情况1：线程1 先执行，这时 ready = false，所以进入 else 分支结果为 1
情况2：线程2 先执行 num = 2，但没来得及执行 ready = true，线程1 执行，还是进入 else 分支，结果为1
情况3：线程2 执行到 ready = true，线程1 执行，这回进入 if 分支，结果为 4（因为 num 已经执行过了）
情况4：线程2 执行 ready = true，切换到线程1，进入 if 分支，相加为 0，再切回线程2 执行 num = 2，出现了指令重排序
*/

int num = 0;
boolean ready = false;
// 线程1 执行此方法
public void actor1(I_Result r) {
     if(ready) {
         r.r1 = num + num;
     } else {
    	 r.r1 = 1;
     }
}
// 线程2 执行此方法
public void actor2(I_Result r) { 
     num = 2;
     ready = true; 
}
```

![](F:/学习资料/Nodes/Java基础/多线程/resources/实验结果.PNG)

可以看到0的结果还是出现了，尽管出现的情况不多。

重排序分为下面几种，为了避免各种重排序，需要加入内存屏障。

<img src="F:/学习资料/Nodes/Java基础/多线程/resources/重排序种类.PNG" style="zoom:50%;" />

- **原子性**-保证指令不会受到线程上下文切换的影响

  下面是一个普通的i++操作。可以看到分了4条指令，必须保证在这四条指令执行的期间不能发生线程切换，否则就会报错。

![](F:/学习资料/Nodes/Java基础/多线程/resources/原子性示意图.PNG)

### Happen-Before原则：

Happen-Before原则，说明的是前一个操作对后一个操作是可见的。这个原则就是方便程序员理解编译器的重排序规则，更好的理解可见性

重排序的原则：

1. 重排序不能改变如下的数据依赖

<img src="F:/学习资料/Nodes/Java基础/多线程/resources/数据依赖.PNG" style="zoom:50%;" />

2. 不管怎么重排序，不能改变程序的执行结果，要像串行一样，即as-if-serial
3. 在临界区内可以重排序，但不能让临界区内的代码逃逸出临界区。synchronized包裹的程序可以重排序，但是不能有里面的变量可以在外面访问。

Happen-Before原则

1.  按照程序顺序，前面的操作 Happens-Before 于后续的任意操作。
2.  一个 volatile 变量的写操作， Happens-Before 于后续对这个 volatile变量的读操作。
3.  这条规则是指如果 A Happens-Before B，且 B Happens-Before C，那么 A Happens-Before C。
4.  这条规则是指对一个锁的解锁 Happens-Before 于后续对这个锁的加锁。
5.  它是指主线程 A 启动子线程 B 后，子线程 B 能够看到主线程在启动子线程 B 前的操作。
6.  它是指主线程 A 等待子线程 B 完成（主线程 A 通过调用子线程 B 的 join() 方法实现），当子线程 B 完成后（主线程 A 中 join() 方法返回），主线程能够看到子线程的操作

## volatile原理

volatile适用一个线程写多个线程读取的情况

有volatile变量修饰的代码，反汇编之后会加上lock前缀，这个前缀会产生两个效果。

- Lock前缀指令会引起处理器缓存写回到内存
- 一个处理器的缓存写回到内存会导致其他处理器的缓存无效。

volatile更底层的实现是内存屏障

- 对volatile的写指令会插入写屏障，写屏障保证在该屏障之前的，对共享变量的改动，都同步到主存当中。
- 对volatile的读指令会插入读屏障，读屏障保证在该屏障之后，对共享变量的读取，加载的是主存中最新数据

volatile禁止重排序的种类：

<img src="F:/学习资料/Nodes/Java基础/多线程/resources/volatile重排序.PNG" style="zoom:50%;" />

- 当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。这个规则确保 volatile写之前的操作不会被编译器重排序到volatile写之后。 

- 当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保 volatile读之后的操作不会被编译器重排序到volatile读之前。 

- 当第一个操作是volatile写，第二个操作是volatile读时，不能重排序。

为了实现上面的语义，需要以下重排序操作的配合。

<img src="F:/学习资料/Nodes/Java基础/多线程/resources/内存屏障类型.PNG" style="zoom:50%;" />

- 在每个volatile写操作的前面插入一个StoreStore屏障。 

- 在每个volatile写操作的后面插入一个StoreLoad屏障。 

- 在每个volatile读操作的后面插入一个LoadLoad屏障。 

- 在每个volatile读操作的后面插入一个LoadStore屏障。

  下面的LoadLoad屏障用来禁止处理器把上面的volatile读与下面的普通读重排序。LoadStore屏障用来禁止处理器把上面的volatile读与下面的普通写重排序

  <img src="F:/学习资料/Nodes/Java基础/多线程/resources/volatile读插入的屏障.PNG" style="zoom:50%;" />

下面的StoreStore屏障可以保证在volatile写之前，其前面的所有普通写操作已经对任 意处理器可见了。这是因为StoreStore屏障将保障上面所有的普通写在volatile写之前刷新到主内存。volatile写后面的StoreLoad屏障的作用是避免volatile写与后面可能有的volatile读/写操作重排序

<img src="F:/学习资料/Nodes/Java基础/多线程/resources/volatile写插入的屏障.PNG" style="zoom:50%;" />

## synchronized实现原理

### Java对象头

对象在内存中分为三块区域：

- 对象头

  1. MarkWord(标记字段)，默认存储对象的HashCode，分代年龄和锁标志位信息。里面存储的数据会随着锁标志位的变化而变化。
  2. Klass Point(类型指针)，对象指向它的类元数据指针，通过这个指针确定对象是那个类的实例

- 实例数据

  存放类的数据信息，父类信息

- 对齐填充

  虚拟机要求对象起始地址必须是8字节的整倍数，填充数据不是必须存在的，仅仅是为了字节对齐

32位虚拟机中对象头的组成

![](F:/学习资料/Nodes/Java基础/多线程/resources/32位虚拟机结构.PNG)

32位虚拟机中对象头的组成
![](F:/学习资料/Nodes/Java基础/多线程/resources/32位虚拟机markword结构.PNG)
64位虚拟机中对象头的组成

![](F:/学习资料/Nodes/Java基础/多线程/resources/64位虚拟机markword结构.PNG)

**biased_lock**：对象是否启用偏向锁标记，只占1个二进制位。为1时表示对象启用偏向锁，为0时表示对象没有偏向锁。
 **age**：4位的Java对象年龄。在GC中，如果对象在Survivor区复制一次，年龄增加1。当对象达到设定的阈值时，将会晋升到老年代。默认情况下，并行GC的年龄阈值为15，并发GC的年龄阈值为6。由于age只有4位，所以最大值为15，这就是`-XX:MaxTenuringThreshold`选项最大值为15的原因。
 **identity_hashcode**：25位的对象标识Hash码，采用延迟加载技术。调用方法`System.identityHashCode()`计算，并会将结果写到该对象头中。当对象被锁定时，该值会移动到管程Monitor中。
 **thread**：持有偏向锁的线程ID。
 **epoch**：偏向时间戳。
 **ptr_to_lock_record**：指向栈中锁记录的指针。
 **ptr_to_heavyweight_monitor**：指向管程Monitor的指针。

### 管程

管程，对应的英文是Monitor，指管理共享变量以及对共享变量操作的过程，让他们支持并发。在管程的发展历史上分别有三种不同的管程模型，分别是Hasen模型，Hoare模型，MESA模型。

并发领域要解决的问题：

- 互斥：即同一时刻只允许一个线程访问共享资源。
- 同步：即线程之间如何通信，协作。

管程的解决方法：

- 互斥：将共享变量及其对共享变量的操作统一封装起来。

- 同步：利用条件变量和条件变量等待队列。

  ![](F:/学习资料/Nodes/Java基础/多线程/resources/MESA管程模型.PNG)

在管程模型里，共享变量和对共享变量的操作是被封装起来的，最外层的框就是封装的意思。每一个条件变量都对应一个等待队列。例如，现在线程T1执行阻塞队列的出队操作，如果队列是空的就到条件变量对应的等待队列里面等。如果T2执行阻塞队列的入队操作。队列满了，进入对应条件变量的等待队列里面等。

```java
//阻塞队列的实现上面的思想
public class BlockedQueue<T>{
  final Lock lock =
    new ReentrantLock();
  // 条件变量：队列不满  
  final Condition notFull =
    lock.newCondition();
  // 条件变量：队列不空  
  final Condition notEmpty =
    lock.newCondition();

  // 入队
  void enq(T x) {
    lock.lock();
    try {
      while (队列已满){
        // 等待队列不满 
        notFull.await();
      }  
      // 省略入队操作...
      //入队后,通知可出队
      notEmpty.signal();
    }finally {
      lock.unlock();
    }
  }
  // 出队
  void deq(){
    lock.lock();
    try {
      while (队列已空){
        // 等待队列不空
        notEmpty.await();
      }
      // 省略出队操作...
      //出队后，通知可入队
      notFull.signal();
    }finally {
      lock.unlock();
    }  
  }
}
```

1. Hasen 模型里面，要求 notify() 放在代码的最后，这样 T2 通知完 T1 后，T2 就结束了，然后 T1 再执行，这样就能保证同一时刻只有一个线程执行。
2. Hoare 模型里面，T2 通知完 T1 后，T2 阻塞，T1 马上执行；等 T1 执行完，再唤醒 T2，也能保证同一时刻只有一个线程执行。但是相比 Hasen 模型，T2 多了一次阻塞唤醒操作。
3. MESA 管程里面，T2 通知完 T1 后，T2 还是会接着执行，T1 并不立即执行，仅仅是从条件变量的等待队列进到入口等待队列里面。这样做的好处是 notify() 不用放到代码的最后，T2 也没有多余的阻塞唤醒操作。但是也有个副作用，就是当 T1 再次执行的时候，可能曾经满足的条件，现在已经不满足了，所以需要以循环方式检验条件变量。

下面是Java中管程的实现
![](F:/学习资料/Nodes/Java基础/多线程/resources/Java中管程的实现.PNG)

### 各种锁

锁的升级顺序如下

```mermaid
graph LR
A[无锁] -->B[偏向锁] --> C[轻量级锁] -->D[重量级锁]
```

- 偏向锁：解决同一个线程多次获得锁时候的代价。
- 轻量级锁：如果一个对象虽然有多线程访问，但多线程访问的时间是错开的（也就是没有竞争），那可以使用轻量级锁来优化。轻量级锁对使用者是透明的，即语法依然是synchronized

#### 偏向锁

在第一次进入的时候，需要CAS将线程ID放在对象的MarkWord头，之后发现线程ID是自己的就表示没有竞争，不需要重新CAS。只要不发生竞争，这个对象就归线程所有。

- 调用hashcode()方法，会导致偏向锁被禁用，直接调用轻量级锁。因为偏向锁的Markword中没有存储hashcode的位置，轻量级锁会在锁记录中记录hashCode，重量级锁会在Monitor中记录hashCode。

- 当有其他线程调用偏向锁对象的时候，会升级成轻量级锁。注意，是在当前线程执行完synchronized方法之后调用，否则就会升级成重量级锁。

- 调用wait，notify也会撤销偏向锁，因为只有重量级锁有这两个方法。

#### 轻量级锁

加锁过程：

1. 创建锁记录对象(LockRecord)，每个线程的栈帧都会包含一个锁记录的结构，内部可以存储锁定对象的Mark Word。

   <img src="F:/学习资料/Nodes/Java基础/多线程/resources/轻量级锁1.PNG" style="zoom:50%;" />

2. 让锁记录中的Object reference指向锁对象，并尝试用cas替换Object的Mark Word，将MarkWord存入锁记录（就是这里存储了HashCode）。

   <img src="F:/学习资料/Nodes/Java基础/多线程/resources/轻量级锁2.PNG" style="zoom:50%;" />

3. 如果cas替换成功，对象头中存储了锁记录的地址和状态00，表示由该线程给对象加锁。

   <img src="F:/学习资料/Nodes/Java基础/多线程/resources/轻量级锁3.PNG" style="zoom:50%;" />

4. 如果cas失败，有两种情况

   (1)如果是其他线程持有了Object的轻量级锁，表名有竞争，进入锁膨胀过程。

   (2)如果是自己执行了synchronized锁充入，则在添加一条LockRecord作为重入的计数。

   <img src="F:/学习资料/Nodes/Java基础/多线程/resources/轻量级锁4.PNG" style="zoom:50%;" />

锁膨胀：如果别的线程CAS的时候，发现已经有线程加了偏向锁1，自己会申请Monitor锁，让Object指向重量级锁地址，同时自己进入Monitor的EntryList阻塞。

自旋转优化：如果在争取的时候发现阻塞，可以先自旋尝试获取锁，失败10次后进入锁膨胀。

#### 重量级锁

Java中Monitor的详细情况

加入synchonized之后，在子字节码中会出现MonitorEnter和MonitorExit两条指令。

<img src="F:/学习资料/Nodes/Java基础/多线程/resources/Java中Monitor详细.PNG" style="zoom:50%;" />

## 线程池

<img src="F:/学习资料/Nodes/Java基础/多线程/resources/Executor框架.PNG" style="zoom: 67%;" />

Executor框架分为三个大部分，所有实现了Runnable借口和Future接口的类都能被ThreadPoolExecutor和ScheduledThreadPoolExecutor执行：

- 任务：包括被执行任务需要实现的接口：Runnable和Callable接口。

- 任务的执行，ThreadPoolExecutor是线程池的核心实现类，用来执行被提交的任务，ScheduledThreadPoolExecutor是一个延迟后运行的命令。

- 异步计算的结果，Future接口和FutureTask类。

Executor框架执行的示意图如下：主线程创建Runnable或者Callable接口的任务对象，并且提交到ExecutorService执行，执行后如果有结果通过Future对象返回。

  <img src="F:/学习资料/Nodes/Java基础/多线程/resources/Executor框架执行图.PNG" style="zoom:67%;" />

  

  

```java
 public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler) {
```

- corePoolSize核心线程数目（最多保留线程数）
- maximumPoolSize最大线程数目
- keepAliveTime生存时间-针对急救线程
- unit时间单位-针对就即线程
- workQueue阻塞队列
- threadFactory线程工厂-可以为线程创建时起个好名字
- handler拒绝策略

**线程池的工作流程**：

1. 线程池开始的时候没有线程，当任务被提交给线程后，线程池会创建一个新线程来执行任务。

2. 当线程数达到了corePoolSize且并没有线程空闲时间，这时在加入任务，会被添加到workQueue队列排队，直到有空闲的线程。

3. 如果队列选择了有界队列，当任务超过了队列大小时，会创建maximumPoolSize-corePoolSize数目的线程来救急。

4. 当线程达到maximumPoolSize的时候，仍然有任务加入，会执行拒绝策略。

   - AbortPolicy让调用者抛出RejectedExecutionException异常，这是默认策略

   - CallerRunsPolicy让调用者运行任务

   - DiscardPolicy放弃本次任务

   - DiscardPolicy放弃队列中最早的任务，取而代之。

 ![](F:/学习资料/Nodes/Java基础/多线程/resources/拒绝策略.PNG)

## Lock原理

Concurrent包的结构
<img src="F:/学习资料/Nodes/Java基础/多线程/resources/Concurrent包结构.PNG" style="zoom:60%;" />

### Lock锁的内存语义

- 锁释放与volatile写有相同的内存语义，当线程释放锁的时候，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。
- 锁获取与volatile读有相同的内存语义，当线程获取锁时候，JMM会把该线程对应的本地内存置为无效。

### AQS原理

![](F:/学习资料/Nodes/Java基础/多线程/resources/用到了AQS的队列.PNG)

全称是AbstractQueuedSynchronizer，是阻塞式锁和相关同步器工具的框架。

- 用state属性来表示资源的状态（分独占模式和共享模式），子类需要定义如何维护这个状态，控制如何获取锁和释放锁。
  - getState-获取state状态
  - setState-设置state状态
  - compareAndSetState-cas机制设置state状态
  - 独占模式只是有一个线程能访问资源，而共享模式可以允许多个线程访问资源

- 提供了基于FIFO的等待队列，类似于Monitor的EntryList

- 条件变量来实现等待，唤醒机制，支持多个条件变量，类似于Monitor的WaitSet

- 子类要实现这样一些方法（默认抛出UnsupportedOperationException）

  - tryAcquire

  - tryRelease

  - tryAcquireShared

  - tryReleaseShared

  - isHeldExclusively

```java
final class MySync extends AbstractQueuedSynchronizer {
     @Override
     protected boolean tryAcquire(int acquires) {
         if (acquires == 1){
             if (compareAndSetState(0, 1)) {
                 setExclusiveOwnerThread(Thread.currentThread());
                 return true;
             }
         }
         return false;
     }
    
     @Override
     protected boolean tryRelease(int acquires) {
         if(acquires == 1) {
         if(getState() == 0) {
        	 throw new IllegalMonitorStateException();
     	 }
         setExclusiveOwnerThread(null);
         setState(0);
         return true;
         }
         return false;
     }
     
     protected Condition newCondition() {
         return new ConditionObject();
     }
     
     @Override
     protected boolean isHeldExclusively() {
     return getState() == 1;
     }
}

class MyLock implements Lock {
     static MySync sync = new MySync();
     
     @Override
     // 尝试，不成功，进入等待队列
     public void lock() {
         sync.acquire(1);
     }
    
     @Override
     // 尝试，不成功，进入等待队列，可打断
     public void lockInterruptibly() throws InterruptedException {
    	 sync.acquireInterruptibly(1);
     }
    
     @Override
     // 尝试一次，不成功返回，不进入队列
     public boolean tryLock() {
    	 return sync.tryAcquire(1);
     }
    
     @Override
     // 尝试，不成功，进入等待队列，有时限
     public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {
    	 return sync.tryAcquireNanos(1, unit.toNanos(time));
     }
    
     @Override
     // 释放锁
     public void unlock() {
     	sync.release(1);
     }
    
     @Override
     // 生成条件变量
     public Condition newCondition() {
     	return sync.newCondition();
     }
}
```

### ReentrantLock原理

#### 非公平锁实现原理

```java
//默认为非公平锁 
public ReentrantLock() {
        this.sync = new ReentrantLock.NonfairSync();
 }
```

```java
//加锁实现
 		final void lock() {
            //首先cas尝试（仅尝试一次）将state从0变成1，如果成功表示获得了独占锁
            if (compareAndSetState(0, 1))
                setExclusiveOwnerThread(Thread.currentThread());
            else
            //如果尝试失败进入acuire
                acquire(1);
       }
```

<img src="F:/学习资料/Nodes/Java基础/多线程/resources/ReentranLock没有竞争加锁.PNG" style="zoom:60%;" />

```java
//当前线程已经被占用，又有线程来执行。
/*
    Thread-1 执行了
        1. tryAcquire函数，CAS 尝试将 state 由 0 改为 1，结果失败
        2. 接下来进入 addWaiter 逻辑，构造 Node 队列
            图中黄色三角表示该 Node 的 waitStatus 状态，其中 0 为默认正常状态
            Node 的创建是懒惰的
            其中第一个 Node 称为 Dummy（哑元）或哨兵，用来占位，并不关联线程
*/
public final void acquire(int arg) {
        if (!tryAcquire(arg) &&
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            selfInterrupt();
    }
```

<img src="F:/学习资料/Nodes/Java基础/多线程/resources/ReentrantLock加锁失败.PNG" style="zoom:60%;" /> <img src="/resources/ReentrantLock加锁失败2.PNG" style="zoom:60%;" />

```java
//addWaiter()方法
  private Node addWaiter(Node mode) {
      //将当前线程关联到一个Node对象上，模式为独占模式
        Node node = new Node(Thread.currentThread(), mode);
        // 如果tail不为null，cas尝试将Node对象加入AQS队列尾部
        Node pred = tail;
        if (pred != null) {
            node.prev = pred;
            if (compareAndSetTail(pred, node)) {
                //双向链表
                pred.next = node;
                return node;
            }
        }
      //尝试将Node加入AQS中
        enq(node);
        return node;
    }
//enq（）方法
 private Node enq(final Node node) {
        for (;;) {
            Node t = tail;
            if (t == null) { // Must initialize
                //还没有，设置head为哨兵节点
                if (compareAndSetHead(new Node()))
                    tail = head;
            } else {
                //cas尝试将Node对象加入AQS队列尾部
                node.prev = t;
                if (compareAndSetTail(t, node)) {
                    t.next = node;
                    return t;
                }
            }
        }
    }

//进入acquireQueued方法 
/*
1. acquireQueued 会在一个死循环中不断尝试获得锁，失败后进入 park 阻塞
2. 如果自己是紧邻着 head（排第二位），那么再次 tryAcquire 尝试获取锁，当然这时 state 仍为 1，失败
3. 进入 shouldParkAfterFailedAcquire 逻辑，将前驱 node，即 head 的 waitStatus 改为 -1，这次返回 false(-1表示有责任唤醒后继节点)
4. shouldParkAfterFailedAcquire 执行完毕回到 acquireQueued ，再次 tryAcquire 尝试获取锁，当然这时state 仍为 1，失败
5. 当再次进入 shouldParkAfterFailedAcquire 时，这时因为其前驱 node 的 waitStatus 已经是 -1，这次返回true
6. 进入 parkAndCheckInterrupt， Thread-1 park（灰色表示）
*/
final boolean acquireQueued(final Node node, int arg) {
        boolean failed = true;
        try {
            boolean interrupted = false;
            for (;;) {
                final Node p = node.predecessor();  //获取node的前趋节点，如果是第一个节点，尝试获取锁，获取失败进入
                if (p == head && tryAcquire(arg)) {  // 下一个if，
                    setHead(node);                   //获取成功，设置自己为head
                    p.next = null; // help GC
                    failed = false;
                    return interrupted;              //返回中断标记false
                }
                if (shouldParkAfterFailedAcquire(p, node) &&  //是不是应该阻塞，为真阻塞，为假下一个循环
                    parkAndCheckInterrupt())   //park等待，此时Node状态为Node.SIGNAL
                    interrupted = true;
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }

 private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
         // 获取上一个节点的状态
         int ws = pred.waitStatus;
         if (ws == Node.SIGNAL) {
             // 上一个节点都在阻塞, 那么自己也阻塞好了
             return true;
         }
        	 // > 0 表示取消状态
         if (ws > 0) {
             // 上一个节点取消, 那么重构删除前面所有取消的节点, 返回到外层循环重试
             do {
             node.prev = pred = pred.prev;
             } while (pred.waitStatus > 0);
             pred.next = node;
             } else {
             // 这次还没有阻塞
             // 但下次如果重试不成功, 则需要阻塞，这时需要设置上一个节点状态为 Node.SIGNAL
             compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
         }
         return false;
 }
 
 //阻塞当前线程
 private final boolean parkAndCheckInterrupt() {
     LockSupport.park(this);
     return Thread.interrupted();
 }
```

<img src="F:/学习资料/Nodes/Java基础/多线程/resources/ReentrantLock加锁失败3.PNG" style="zoom: 50%;" />                        <img src="F:/学习资料/Nodes/Java基础/多线程/resources/ReentrantLock加锁失败4.PNG" style="zoom: 50%;" /> 
多次竞争失败的示意图
<img src="F:/学习资料/Nodes/Java基础/多线程/resources/ReentrantLock加锁失败5.PNG"  />

```java
//解锁代码
      public void unlock() {
        this.sync.release(1);
      }
   
//release方法      
/*
2.当前队列不为 null，并且 head 的 waitStatus = -1，进入 unparkSuccessor 流程
  找到队列中离 head 最近的一个 Node（没取消的），unpark 恢复其运行，本例中即为 Thread-1
  回到 Thread-1 的 acquireQueued 流程
*/
      public final boolean release(int arg) {
        //尝试释放锁
        if (tryRelease(arg)) {
            //队列头结点unpark
            Node h = head;
            if (h != null && h.waitStatus != 0) //队列不为null，waitStatus==Node.SIGNAL，才需要unpark
                unparkSuccessor(h);
            return true;
        }
        return false;
    }
    
//tryRelease方法
/*
1.设置 exclusiveOwnerThread 为 null,state = 0
*/
    protected final boolean tryRelease(int releases) {
            int c = getState() - releases;
            if (Thread.currentThread() != getExclusiveOwnerThread())
                throw new IllegalMonitorStateException();
            boolean free = false;
            if (c == 0) {
                free = true;
                setExclusiveOwnerThread(null);
            }
            setState(c);
            return free;
        }
    
```

<img src="F:/学习资料/Nodes/Java基础/多线程/resources/ReentrantLock解锁流程1.PNG" style="zoom: 80%;" />
<img src="F:/学习资料/Nodes/Java基础/多线程/resources/ReentrantLock解锁流程2.PNG" style="zoom:80% ;"/>

```java
/*
    1.如果加锁成功（没有竞争），会设置exclusiveOwnerThread 为 Thread-1，state = 1
    head 指向刚刚 Thread-1 所在的 Node，该 Node 清空 Thread
    原本的 head 因为从链表断开，而可被垃圾回收
    如果这时候有其它线程来竞争（非公平的体现），例如这时有 Thread-4 来了
    
    如果不巧又被 Thread-4 占了先
	Thread-4 被设置为 exclusiveOwnerThread，state = 1
	Thread-1 再次进入 acquireQueued 流程，获取锁失败，重新进入 park 阻塞
*/
```

![](F:/学习资料/Nodes/Java基础/多线程/resources/ReentrantLock解锁流程3.PNG)

#### 锁重入原理

```java
  final boolean nonfairTryAcquire(int acquires) {
            final Thread current = Thread.currentThread();
            int c = getState();
      //如果还没有获得锁
            if (c == 0) {
                //尝试用cas获得，这里体现了非公平性，不去检查AQS队列
                if (compareAndSetState(0, acquires)) {
                    setExclusiveOwnerThread(current);
                    return true;
                }
            }
      //如果已经获得了锁，线程还是当前线程，表示发生了锁重入
            else if (current == getExclusiveOwnerThread()) {
                int nextc = c + acquires;
                if (nextc < 0) // overflow
                    throw new Error("Maximum lock count exceeded");
                setState(nextc);
                return true;
            }
      //获取失败，回到调用处
            return false;
        }

  protected final boolean tryRelease(int releases) {
      //state--
            int c = getState() - releases;
            if (Thread.currentThread() != getExclusiveOwnerThread())
                throw new IllegalMonitorStateException();
            boolean free = false;
      //支持锁重入，只有state减为0，才能成功      
      if (c == 0) {
                free = true;
                setExclusiveOwnerThread(null);
            }
            setState(c);
            return free;
        }
```

#### 可打断原理

```java
//不可打断模式
static final class NonfairSync extends Sync {

     private final boolean parkAndCheckInterrupt() {
  
         LockSupport.park(this);                  //1.在这里阻塞，如果打断标记已经是 true, 则 park 会失效
         // interrupted 会清除打断标记
         return Thread.interrupted();             //2.调用interrupted方法，返回true，清楚打断标记
     }

     final boolean acquireQueued(final Node node, int arg) {
         boolean failed = true;
             try {
                 boolean interrupted = false;
                 for (;;) {
                    final Node p = node.predecessor();
                    if (p == head && tryAcquire(arg)) {           //4.获得锁之后，返回true
                         setHead(node);
                         p.next = null;
                         failed = false;
                         // 还是需要获得锁后, 才能返回打断状态
                         return interrupted;
                     }
                     if (
                         shouldParkAfterFailedAcquire(p, node) &&
                         parkAndCheckInterrupt()                          //3.返回这里，记录打断标记为true
                     ) {
                     // 如果是因为 interrupt 被唤醒, 返回打断状态为 true
                     interrupted = true;
                      }
             }
          } finally {
        		 if (failed)
         cancelAcquire(node);
     }
 }
    
    public final void acquire(int arg) {
     if (
         !tryAcquire(arg) &&   
         acquireQueued(addWaiter(Node.EXCLUSIVE), arg)                      //5.自己打断
     ) {
         // 如果打断状态为 true
         selfInterrupt();
     }
 }
 
 static void selfInterrupt() {
     // 重新产生一次中断
     Thread.currentThread().interrupt();
 	}
}
    
//可打断模式

static final class NonfairSync extends Sync {
    
     public final void acquireInterruptibly(int arg) throws InterruptedException {
         if (Thread.interrupted())
         throw new InterruptedException();
         // 如果没有获得到锁, 进入 ㈠
         if (!tryAcquire(arg))
         doAcquireInterruptibly(arg);
 }
 
 // ㈠ 可打断的获取锁流程
 private void doAcquireInterruptibly(int arg) throws InterruptedException {
     final Node node = addWaiter(Node.EXCLUSIVE);
     boolean failed = true;
     try {
         for (;;) {
         final Node p = node.predecessor();
         if (p == head && tryAcquire(arg)) {
             setHead(node);
             p.next = null; // help GC
             failed = false;
             return;
         }
         if (shouldParkAfterFailedAcquire(p, node) &&
             parkAndCheckInterrupt()) {
                 // 在 park 过程中如果被 interrupt 会进入此
             // 这时候抛出异常, 而不会再次进入 for (;;)
             throw new InterruptedException();
             }
         }
         } finally {
         if (failed)
         cancelAcquire(node);
     }
 }
}
```

#### 条件变量实现原理

```java
//await方法 
public final void await() throws InterruptedException {
            if (Thread.interrupted())
                throw new InterruptedException();
            //添加一个Node到等待队列
            Node node = addConditionWaiter();
            //释放节点持有的锁
            int savedState = fullyRelease(node);
            int interruptMode = 0;
            //如果该节点还没有移至AQS队列，阻塞
            while (!isOnSyncQueue(node)) {
                //阻塞
                LockSupport.park(this);
                //如果被打断，退出等待队列
                if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
                    break;
            }
             //退出等待队列后，还要获得AQS队列的锁
            if (acquireQueued(node, savedState) && interruptMode != THROW_IE)
                interruptMode = REINTERRUPT;
            //所有取消的Node从队列链表删除
            if (node.nextWaiter != null) // clean up if cancelled
                unlinkCancelledWaiters();
            //应用打断模式
            if (interruptMode != 0)
                reportInterruptAfterWait(interruptMode);
        }
```

- Thread-0持有锁，调用await，进入ConditionObject的addConditionWaiter流程，创建新的Node状态为-2，关联Thread-），加入等待队列尾部。
- 接下来进入AQS的fullyRelease流程，释放同步器上的锁
- unpark AQS队列中的下一个节点，竞争锁，假设没有其他线程竞争，Thread-1竞争成功
- park阻塞Thread-0

<img src="F:/学习资料/Nodes/Java基础/多线程/resources/ReentrantLock中await方法1.PNG" style="zoom:60%;" />

<img src="F:/学习资料/Nodes/Java基础/多线程/resources/ReentrantLock中await方法1.PNG" style="zoom:60%;" />

```java
 // 唤醒 - 必须持有锁才能唤醒, 因此 doSignal 内无需考虑加锁
 public final void signal() {
     if (!isHeldExclusively())
     	 throw new IllegalMonitorStateException();
    	 Node first = firstWaiter;
     if (first != null)
     	doSignal(first);
 }


 // 唤醒 - 将没取消的第一个节点转移至 AQS 队列
 private void doSignal(Node first) {
     do {
         // 已经是尾节点了
         if ( (firstWaiter = first.nextWaiter) == null) {
             lastWaiter = null;
         }
             first.nextWaiter = null;
     } while (
             // 将等待队列中的 Node 转移至 AQS 队列, 不成功且还有节点则继续循环
             !transferForSignal(first) &&
             // 队列还有节点
             (first = firstWaiter) != null
     );
 }
 
 //如果节点状态是取消, 返回 false 表示转移失败, 否则转移成功
 final boolean transferForSignal(Node node) {
     // 如果状态已经不是 Node.CONDITION, 说明被取消了
     if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))
    	 return false;
         // 加入 AQS 队列尾部
         Node p = enq(node);
         int ws = p.waitStatus;
         if (
             // 上一个节点被取消
             ws > 0 ||
             // 上一个节点不能设置状态为 Node.SIGNAL
             !compareAndSetWaitStatus(p, ws, Node.SIGNAL) 
         ) {
       	  // unpark 取消阻塞, 让线程重新同步状态
        	 LockSupport.unpark(node.thread);
      }
     return true;
 }
```

<img src="F:\学习资料\Nodes\Java基础\多线程\resources\ReentrantLock中signal1.PNG" style="zoom:60%;" />

<img src="F:\学习资料\Nodes\Java基础\多线程\resources\ReentrantLock中的signal2.PNG" style="zoom:60%;" />

### ReentrantReadWriteLock

- **t1 w.lock**，**t2 r.lock**

#### 写锁先加锁，读锁后加锁的情况

<img src="F:/学习资料/Nodes/Java基础/多线程/resources/ReentrantReadWriteLock1.PNG" style="zoom:60%;" />



1. t1 成功上锁，流程与 ReentrantLock 加锁相比没有特殊之处，不同是写锁状态占了 state 的低 16 位，而读锁

使用的是 state 的高 16 位 

2. t2 执行 r.lock，这时进入读锁的 sync.acquireShared(1) 流程，首先会进入 tryAcquireShared 流程。如果有写

锁占据，那么 tryAcquireShared 返回 -1 表示失败

3. 这时会进入 sync.doAcquireShared(1) 流程，首先也是调用 addWaiter 添加节点，不同之处在于节点被设置为

Node.SHARED 模式而非 Node.EXCLUSIVE 模式，注意此时 t2 仍处于活跃状态

4. t2 会看看自己的节点是不是老二，如果是，还会再次调用 tryAcquireShared(1) 来尝试获取锁
5. 如果没有成功，在 doAcquireShared 内 for (;;) 循环一次，把前驱节点的 waitStatus 改为 -1，再 for (;;) 循环一次尝试 tryAcquireShared(1) 如果还不成功，那么在 parkAndCheckInterrupt() 处 park

<img src="F:/学习资料/Nodes/Java基础/多线程/resources/ReentrantReadWriteLock2.PNG" style="zoom:60%;" /><img src="F:/学习资料/Nodes/Java基础/多线程/resources/ReentrantReadWriteLock3.PNG" style="zoom:60%;" />

<img src="F:/学习资料/Nodes/Java基础/多线程/resources/ReentrantReadWriteLock4.PNG" style="zoom:60%;" />

#### 读锁先加锁，写锁后加锁

- 这种状态下，假设又有 t3 加读锁和 t4 加写锁，这期间 t1 仍然持有锁，就变成了下面的样子

<img src="F:/学习资料/Nodes/Java基础/多线程/resources/ReentrantReadWriteLock5.PNG" style="zoom:60%;" />

#### 写锁解锁

1. 这时会走到写锁的 sync.release(1) 流程，调用 sync.tryRelease(1) 成功，变成下面的样子

   <img src="F:/学习资料/Nodes/Java基础/多线程/resources/ReentrantReadWriteLock6.PNG" style="zoom:60%;" />

2. 接下来执行唤醒流程 sync.unparkSuccessor，即让老二恢复运行，这时 t2 在 doAcquireShared 内parkAndCheckInterrupt() 处恢复运行，这回再来一次 for (;;) 执行 tryAcquireShared 成功则让读锁计数加一

3. 这时 t2 已经恢复运行，接下来 t2 调用 setHeadAndPropagate(node, 1)，它原本所在节点被置为头节点

4. 事情还没完，在 setHeadAndPropagate 方法内还会检查下一个节点是否是 shared，如果是则调用doReleaseShared() 将 head 的状态从 -1 改为 0 并唤醒老二，这时 t3 在 doAcquireShared 内parkAndCheckInterrupt() 处恢复运行

5. 这回再来一次 for (;;) 执行 tryAcquireShared 成功则让读锁计数加一

<img src="F:/学习资料/Nodes/Java基础/多线程/resources/ReentrantReadWriteLock7.PNG" style="zoom:50%;" /><img src="F:/学习资料/Nodes/Java基础/多线程/resources/ReentrantReadWriteLock8.PNG" style="zoom:50%;" />

6. 这时 t3 已经恢复运行，接下来 t3 调用 setHeadAndPropagate(node, 1)，它原本所在节点被置为头节点
7. 下一个节点不是 shared 了，因此不会继续唤醒 t4 所在节点

<img src="F:/学习资料/Nodes/Java基础/多线程/resources/ReentrantReadWriteLock9.PNG" style="zoom:50%;" /><img src="F:/学习资料/Nodes/Java基础/多线程/resources/ReentrantReadWriteLock10.PNG" style="zoom:50%;" />

#### 读锁解锁

1. t2 进入 sync.releaseShared(1) 中，调用 tryReleaseShared(1) 让计数减一，但由于计数还不为零

2. t3 进入 sync.releaseShared(1) 中，调用 tryReleaseShared(1) 让计数减一，这回计数为零了，进入doReleaseShared() 将头节点从 -1 改为 0 并唤醒老二，即
3. 之后 t4 在 acquireQueued 中 parkAndCheckInterrupt 处恢复运行，再次 for (;;) 这次自己是老二，并且没有其他竞争，tryAcquire(1) 成功，修改头结点，流程结束

<img src="F:/学习资料/Nodes/Java基础/多线程/resources/ReentrantReadWriteLock11.PNG" style="zoom:50%;" /><img src="F:/学习资料/Nodes/Java基础/多线程/resources/ReentrantReadWriteLock12.PNG" style="zoom:50%;" />

<img src="F:/学习资料/Nodes/Java基础/多线程/resources/ReentrantReadWriteLock13.PNG" style="zoom:60%;" />

```java
        //写锁上锁流程
        public void lock() {
            sync.acquire(1);
        }


        public final void acquire(int arg) {
            //尝试获取写锁失败
        if (!tryAcquire(arg) &&
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))//将当前线程关联到一个Node上，为独占模式
            selfInterrupt();
       }


        protected final boolean tryAcquire(int acquires) {
            /*
             * Walkthrough:
             * 1. If read count nonzero or write count nonzero
             *    and owner is a different thread, fail.
             * 2. If count would saturate, fail. (This can only
             *    happen if count is already nonzero.)
             * 3. Otherwise, this thread is eligible for lock if
             *    it is either a reentrant acquire or
             *    queue policy allows it. If so, update state
             *    and set owner.
             */
            //获取低十六位代表写锁的state计数
            Thread current = Thread.currentThread();
            int c = getState();
            int w = exclusiveCount(c);
            if (c != 0) {
                // (如果c!=0 and w==0,表示有读锁。c!=0,w!=0,需要判断是不是重入，如果锁不是自己，返回false)
                if (w == 0 || current != getExclusiveOwnerThread())
                    return false;
                //重入次数大于最大值，报错
                if (w + exclusiveCount(acquires) > MAX_COUNT)
                    throw new Error("Maximum lock count exceeded");
                // 写锁重入
                setState(c + acquires);
                return true;
            }
            //判断写锁是否阻塞，或者尝试更改计数失败
            if (writerShouldBlock() ||
                !compareAndSetState(c, c + acquires))
                //获得锁失败
                return false;
            //获得锁成功
            setExclusiveOwnerThread(current);
            return true;
        }
```

```java
        //写锁释放流程
        public void unlock() {
            sync.release(1);
        }


        public final boolean release(int arg) {
        if (tryRelease(arg)) {
            //unpark AQS中等待的线程
            Node h = head;
            if (h != null && h.waitStatus != 0)
                unparkSuccessor(h);
            return true;
        }
        return false;
        }

        protected final boolean tryRelease(int releases) {
            if (!isHeldExclusively())
                throw new IllegalMonitorStateException();
            int nextc = getState() - releases;
            //因为可重入的原因，写锁计数为0，才算释放成功
            boolean free = exclusiveCount(nextc) == 0;
            if (free)
                setExclusiveOwnerThread(null);
            setState(nextc);
            return free;
        }
```





```java
     //读锁加锁流程
     public void lock() {
            sync.acquireShared(1);
     }

      public final void acquireShared(int arg) {
          //tryAcquireShared返回负数，表示获取读锁失败
        if (tryAcquireShared(arg) < 0)
            doAcquireShared(arg);
     }


     protected final int tryAcquireShared(int unused) {
            /*
             * Walkthrough:
             * 1. If write lock held by another thread, fail.
             * 2. Otherwise, this thread is eligible for
             *    lock wrt state, so ask if it should block
             *    because of queue policy. If not, try
             *    to grant by CASing state and updating count.
             *    Note that step does not check for reentrant
             *    acquires, which is postponed to full version
             *    to avoid having to check hold count in
             *    the more typical non-reentrant case.
             * 3. If step 2 fails either because thread
             *    apparently not eligible or CAS fails or count
             *    saturated, chain to version with full retry loop.
             */
            Thread current = Thread.currentThread();
            int c = getState();
           //其他线程持有写锁，读锁获取失败
            if (exclusiveCount(c) != 0 &&
                getExclusiveOwnerThread() != current)
                return -1;
            int r = sharedCount(c);
         //读锁不该阻塞，并且加读锁次数小于最大值，并且加锁成功，返回1
            if (!readerShouldBlock() &&
                r < MAX_COUNT &&
                compareAndSetState(c, c + SHARED_UNIT)) {
                if (r == 0) {
                    firstReader = current;
                    firstReaderHoldCount = 1;
                } else if (firstReader == current) {
                    firstReaderHoldCount++;
                } else {
                    HoldCounter rh = cachedHoldCounter;
                    if (rh == null || rh.tid != getThreadId(current))
                        cachedHoldCounter = rh = readHolds.get();
                    else if (rh.count == 0)
                        readHolds.set(rh);
                    rh.count++;
                }
                return 1;
            }
            return fullTryAcquireShared(current);
        }


        // 非公平锁 readerShouldBlock 看 AQS 队列中第一个节点是否是写锁
        // true 则该阻塞, false 则不阻塞
 		final boolean readerShouldBlock() {
 			return apparentlyFirstQueuedIsExclusive();
 		}

   // 与 tryAcquireShared 功能类似, 但会不断尝试 for (;;) 获取读锁, 执行过程中无阻塞
       final int fullTryAcquireShared(Thread current) {
            /*
             * This code is in part redundant with that in
             * tryAcquireShared but is simpler overall by not
             * complicating tryAcquireShared with interactions between
             * retries and lazily reading hold counts.
             */
            HoldCounter rh = null;
            for (;;) {
                int c = getState();
                if (exclusiveCount(c) != 0) {
                    if (getExclusiveOwnerThread() != current)
                        return -1;
                    // else we hold the exclusive lock; blocking here
                    // would cause deadlock.
                } else if (readerShouldBlock()) {
                    // Make sure we're not acquiring read lock reentrantly
                    if (firstReader == current) {
                        // assert firstReaderHoldCount > 0;
                    } else {
                        if (rh == null) {
                            rh = cachedHoldCounter;
                            if (rh == null || rh.tid != getThreadId(current)) {
                                rh = readHolds.get();
                                if (rh.count == 0)
                                    readHolds.remove();
                            }
                        }
                        if (rh.count == 0)
                            return -1;
                    }
                }
                if (sharedCount(c) == MAX_COUNT)
                    throw new Error("Maximum lock count exceeded");
                if (compareAndSetState(c, c + SHARED_UNIT)) {
                    if (sharedCount(c) == 0) {
                        firstReader = current;
                        firstReaderHoldCount = 1;
                    } else if (firstReader == current) {
                        firstReaderHoldCount++;
                    } else {
                        if (rh == null)
                            rh = cachedHoldCounter;
                        if (rh == null || rh.tid != getThreadId(current))
                            rh = readHolds.get();
                        else if (rh.count == 0)
                            readHolds.set(rh);
                        rh.count++;
                        cachedHoldCounter = rh; // cache for release
                    }
                    return 1;
                }
            }
        }

```



```java
      //读锁释放过程
      public void unlock() {
            sync.releaseShared(1);
       }


      public final boolean releaseShared(int arg) {
        if (tryReleaseShared(arg)) {
            doReleaseShared();
            return true;
        }
        return false;
      }

     protected final boolean tryReleaseShared(int unused) {
            Thread current = Thread.currentThread();
            if (firstReader == current) {
                // assert firstReaderHoldCount > 0;
                if (firstReaderHoldCount == 1)
                    firstReader = null;
                else
                    firstReaderHoldCount--;
            } else {
                HoldCounter rh = cachedHoldCounter;
                if (rh == null || rh.tid != getThreadId(current))
                    rh = readHolds.get();
                int count = rh.count;
                if (count <= 1) {
                    readHolds.remove();
                    if (count <= 0)
                        throw unmatchedUnlockException();
                }
                --rh.count;
            }
            for (;;) {
                int c = getState();
                int nextc = c - SHARED_UNIT;
                if (compareAndSetState(c, nextc))
                    // Releasing the read lock has no effect on readers,
                    // but it may allow waiting writers to proceed if
                    // both read and write locks are now free.
                    return nextc == 0;
            }
        }

    private void doReleaseShared() {
        /*
         * Ensure that a release propagates, even if there are other
         * in-progress acquires/releases.  This proceeds in the usual
         * way of trying to unparkSuccessor of head if it needs
         * signal. But if it does not, status is set to PROPAGATE to
         * ensure that upon release, propagation continues.
         * Additionally, we must loop in case a new node is added
         * while we are doing this. Also, unlike other uses of
         * unparkSuccessor, we need to know if CAS to reset status
         * fails, if so rechecking.
         */
        
        // 如果 head.waitStatus == Node.SIGNAL ==> 0 成功, 下一个节点 unpark
        // 如果 head.waitStatus == 0 ==> Node.PROPAGATE
        for (;;) {
            Node h = head;
            if (h != null && h != tail) {
                int ws = h.waitStatus;
                // 如果有其它线程也在释放读锁，那么需要将 waitStatus 先改为 0
                // 防止 unparkSuccessor 被多次执行
                if (ws == Node.SIGNAL) {
                    if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))
                        continue;            // loop to recheck cases
                    unparkSuccessor(h);
                }
                // 如果已经是 0 了，改为 -3，用来解决传播性，见后文信号量 bug 分析
                else if (ws == 0 &&
                         !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))
                    continue;                // loop on failed CAS
            }
            if (h == head)                   // loop if head changed
                break;
        }
    }

```

## 集合类

<img src="F:/学习资料/Nodes/Java基础/多线程/resources/Queue框架图.PNG" style="zoom:60%;" />

<img src="F:/学习资料/Nodes/Java基础/多线程/resources/Map框架图.PNG"  />

### ConcurrentHashMap 1.8源码

#### 重要属性和内部类

```java
// 默认为 0
// 当初始化时, 为 -1
// 当扩容时, 为 -(1 + 扩容线程数)
// 当初始化或扩容完成后，为 下一次的扩容的阈值大小
private transient volatile int sizeCtl;

// 整个 ConcurrentHashMap 就是一个 Node[]
static class Node<K,V> implements Map.Entry<K,V> {
        final int hash;                  //hash值
        final K key;                     
        volatile V val;
        volatile Node<K,V> next;         //指向下一个节点
}

// hash 表
transient volatile Node<K,V>[] table;   

// 扩容时的 新 hash 表
private transient volatile Node<K,V>[] nextTable;

// 扩容时如果某个 bin 迁移完毕, 用 ForwardingNode 作为旧 table bin 的头结点
static final class ForwardingNode<K,V> extends Node<K,V> {}

// 用在 compute 以及 computeIfAbsent 时, 用来占位, 计算完成后替换为普通 Node
static final class ReservationNode<K,V> extends Node<K,V> {}

// 作为 treebin 的头节点, 存储 root 和 first
static final class TreeBin<K,V> extends Node<K,V> {}

// 作为 treebin 的节点, 存储 parent, left, right
static final class TreeNode<K,V> extends Node<K,V> {}
```

#### 重要方法

```java
// 获取 Node[] 中第 i 个 Node
static final <K,V> Node<K,V> tabAt(Node<K,V>[] tab, int i)
 
// cas 修改 Node[] 中第 i 个 Node 的值, c 为旧值, v 为新值
static final <K,V> boolean casTabAt(Node<K,V>[] tab, int i, Node<K,V> c, Node<K,V> v)
 
// 直接修改 Node[] 中第 i 个 Node 的值, v 为新值
static final <K,V> void setTabAt(Node<K,V>[] tab, int i, Node<K,V> v)
```

#### 构造器分析

```java
//懒惰初始化，第一次调用的时候才会真正初始化，1.8的风格
public ConcurrentHashMap(int initialCapacity,
                             float loadFactor, int concurrencyLevel) {
        if (!(loadFactor > 0.0f) || initialCapacity < 0 || concurrencyLevel <= 0)
            throw new IllegalArgumentException();
        if (initialCapacity < concurrencyLevel)   // Use at least as many bins
            initialCapacity = concurrencyLevel;   // as estimated threads
        long size = (long)(1.0 + (long)initialCapacity / loadFactor);
        int cap = (size >= (long)MAXIMUM_CAPACITY) ?
            MAXIMUM_CAPACITY : tableSizeFor((int)size);
        this.sizeCtl = cap;
    }
```

#### get流程

```java
public V get(Object key) {
        Node<K,V>[] tab; Node<K,V> e, p; int n, eh; K ek;
        //确保方法返回的是正数
        int h = spread(key.hashCode());
        //表不为空，且长度大于0说明有元素才会查找，否则直接返回false
        if ((tab = table) != null && (n = tab.length) > 0 &&
           //找到存储元素的位置，并返回，数组中的元素。
            (e = tabAt(tab, (n - 1) & h)) != null) {
            //如果头节点已经是要查找的key
            if ((eh = e.hash) == h) {
                if ((ek = e.key) == key || (ek != null && key.equals(ek)))
                    return e.val;
            }
            // hash 为负数表示该 bin 在扩容中或是 treebin, 这时调用 find 方法来查找
            else if (eh < 0)
                return (p = e.find(h, key)) != null ? p.val : null;
            // 正常遍历链表, 用 equals 比较
            while ((e = e.next) != null) {
                if (e.hash == h &&
                    ((ek = e.key) == key || (ek != null && key.equals(ek))))
                    return e.val;
            }
        }
        return null;
    }

```

#### put流程

```java
 public V put(K key, V value) {
        return putVal(key, value, false);
    }

 /** Implementation for put and putIfAbsent */
    final V putVal(K key, V value, boolean onlyIfAbsent) {
        if (key == null || value == null) throw new NullPointerException();
        //spread方法结合高位低位，具有更好的hash性
        int hash = spread(key.hashCode());
        int binCount = 0;
        
        for (Node<K,V>[] tab = table;;) {
            // f 是链表头节点
            // fh 是链表头结点的 hash
            // i 是链表在 table 中的下标
            Node<K,V> f; int n, i, fh;
            if (tab == null || (n = tab.length) == 0)
                //第一添加元素的时候，创建整个表，初始化 table 使用了 cas, 无需 synchronized 创建成功, 进入下一轮循环
                tab = initTable();
            //数组中该位置没有放过元素，创建链表头结点
            else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {
                // 添加链表头使用了 cas, 无需 synchronized
                if (casTabAt(tab, i, null,
                             new Node<K,V>(hash, key, value, null)))
                    break;                   // no lock when adding to empty bin
            }
            //发现该位置在扩容，帮忙扩容
            else if ((fh = f.hash) == MOVED)
                tab = helpTransfer(tab, f);
            else {
                V oldVal = null;
                //锁住链表头结点
                synchronized (f) {
                    //再次确认链表有没有被移动
                    if (tabAt(tab, i) == f) {
                        if (fh >= 0) {
                            binCount = 1;
                            //遍历链表
                            for (Node<K,V> e = f;; ++binCount) {
                                K ek;
                                //找到相同的key
                                if (e.hash == hash &&
                                    ((ek = e.key) == key ||
                                     (ek != null && key.equals(ek)))) {
                                    oldVal = e.val;
                                    //更新
                                    if (!onlyIfAbsent)
                                        e.val = value;
                                    break;
                                }
                                //没有发现相同的节点，新增节点
                                Node<K,V> pred = e;
                                if ((e = e.next) == null) {
                                    pred.next = new Node<K,V>(hash, key,
                                                              value, null);
                                    break;
                                }
                            }
                        }
                        //红黑树
                        else if (f instanceof TreeBin) {
                            Node<K,V> p;
                            binCount = 2;
                            // putTreeVal 会看 key 是否已经在树中, 是, 则返回对应的 TreeNode
                            if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key,
                                                           value)) != null) {
                                oldVal = p.val;
                                if (!onlyIfAbsent)
                                    p.val = value;
                            }
                        }
                    }
                }
                if (binCount != 0) {
                    // 如果链表长度 >= 树化阈值(8), 进行链表转为红黑树
                    if (binCount >= TREEIFY_THRESHOLD)
                        treeifyBin(tab, i);
                    if (oldVal != null)
                        return oldVal;
                    break;
                }
            }
        }
        // 增加 size 计数
        addCount(1L, binCount);
        return null;
    }


  private final Node<K,V>[] initTable() {
        Node<K,V>[] tab; int sc;
        while ((tab = table) == null || tab.length == 0) {
            if ((sc = sizeCtl) < 0)
                Thread.yield(); // lost initialization race; just spin
            // 尝试将 sizeCtl 设置为 -1（表示初始化 table）
            else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {
                // 获得锁, 创建 table, 这时其它线程会在 while() 循环中 yield 直至 table 创建
                try {
                    if ((tab = table) == null || tab.length == 0) {
                        int n = (sc > 0) ? sc : DEFAULT_CAPACITY;
                        @SuppressWarnings("unchecked")
                        Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n];
                        table = tab = nt;
                        sc = n - (n >>> 2);
                    }
                } finally {
                    sizeCtl = sc;
                }
                break;
            }
        }
        return tab;
    }

private final void addCount(long x, int check) {
        CounterCell[] as; long b, s;
        // 已经有了 counterCells, 向 cell 累加
        if ((as = counterCells) != null ||
            // 还没有, 向 baseCount 累加
            !U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x)) {
            CounterCell a; long v; int m;
            boolean uncontended = true;
            // 还没有 counterCells
            if (as == null || (m = as.length - 1) < 0 ||
                // 还没有 cell
                (a = as[ThreadLocalRandom.getProbe() & m]) == null ||
                // cell cas 增加计数失败
                !(uncontended =
                  U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) {
                // 创建累加单元数组和cell, 累加重试
                fullAddCount(x, uncontended);
                return;
            }
            if (check <= 1)
                return;
            // 获取元素个数
            s = sumCount();
        }
        if (check >= 0) {
            Node<K,V>[] tab, nt; int n, sc;
            while (s >= (long)(sc = sizeCtl) && (tab = table) != null &&
                   (n = tab.length) < MAXIMUM_CAPACITY) {
                int rs = resizeStamp(n);
                if (sc < 0) {
                    if ((sc >>> RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||
                        sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||
                        transferIndex <= 0)
                        break;
                    if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))
                        transfer(tab, nt);
                }
                else if (U.compareAndSwapInt(this, SIZECTL, sc,
                                             (rs << RESIZE_STAMP_SHIFT) + 2))
                    transfer(tab, null);
                s = sumCount();
            }
        }
    }
```

#### size计算流程

```java
/*
	size 计算实际发生在 put，remove 改变集合元素的操作之中
	没有竞争发生，向 baseCount 累加计数
	有竞争发生，新建 counterCells，向其中的一个 cell 累加计数
	counterCells 初始有两个 cell
	如果计数竞争比较激烈，会创建新的 cell 来累加计数
*/
public int size() {
     long n = sumCount();
     return ((n < 0L) ? 0 :
     		(n > (long)Integer.MAX_VALUE) ? Integer.MAX_VALUE :
     		(int)n);
}
final long sumCount() {
     CounterCell[] as = counterCells; CounterCell a;
     // 将 baseCount 计数与所有 cell 计数累加
     long sum = baseCount;
     if (as != null) {
         for (int i = 0; i < as.length; ++i) {
             if ((a = as[i]) != null)
             sum += a.value;
         }
     }
	 return sum; 
 }
```

Java 8  数组（Node） +（ 链表 Node | 红黑树 TreeNode ） 以下数组简称（table），链表简称（bin）

- 初始化，使用 cas 来保证并发安全，懒惰初始化 table树化，当 table.length < 64 时，先尝试扩容，超过 64 时，并且 bin.length > 8 时，会将链表树化，树化过程会用 synchronized 锁住链表头

- put，如果该 bin 尚未创建，只需要使用 cas 创建 bin；如果已经有了，锁住链表头进行后续 put 操作，元素添加至 bin 的尾部

- get，无锁操作仅需要保证可见性，扩容过程中 get 操作拿到的是 ForwardingNode 它会让 get 操作在新table 进行搜索

- 扩容，扩容时以 bin 为单位进行，需要对 bin 进行 synchronized，但这时妙的是其它竞争线程也不是无事可做，它们会帮助把其它 bin 进行扩容，扩容时平均只有 1/6 的节点会把复制到新 table 中size，元素个数保存在 baseCount 中，并发时的个数变动保存在 CounterCell[] 当中。最后统计数量时累加即可

#  多线程设计模式

## 互斥-保证线程安全

### Single Threaded Execution 模式

多线程容易产生问题，为了不产生问题，需要保证一些核心代码一次只有一个线程执行。通过synchronized来保证线程安全。不过锁的力度太多，影响并发效果。比如HashTable所有的方法都加了synchronized，虽然保证了线程安全，但是也失去了效率

### Read-Write-Lock模式

上面的Single Threaded Execution模式中的synchronized中锁的力度太大，为了提高在读多写少的情况下的性能，引入了这个模式，多个线程读取操作不互斥，读锁和写锁互斥。ReentrantReadWriteLock就是解决这个问题设计的，为了进一步提升性能引入stampedLock

### Immutable模式

多线程访问共享变量的时候会出现问题，如果共享的变量不再发生改变，那么也就不会出现问题。将类中属性，类都声明为final即可实现该模式，享元模式某种程度也是不变的，Integer类，String类


### Thread-Specific Storage模式

多线程同时访问一个资源会出问题，上面的模式分别从控制资源不变，控制访问资源的线程是一个来解决这个问题。这个模式是给每个线程一个资源，让每个线程干自己的事情。利用ThreadLocal来实现每一个线程份变量。

```java
class TSLog{
    private PrintWriter writer = null;

    public TSLog(String filename){
        try{
            writer = new PrintWriter(new FileWriter(filename));
        }catch (IOException e){
            e.printStackTrace();
        }
    }

    public void println(String s){
        writer.println(s);
    }

    public void close(){
        writer.println("====End of log====");
        writer.close();
    }
}

class Log1{
    //利用ThreadLocal给每一个线程一个TSLog对象
    private static final ThreadLocal<TSLog> tsLogCollection = new ThreadLocal<TSLog>();

    public static void println(String s){
        getTSLog().println(s);
    }

    public static void close(){
        getTSLog().close();
    }

    private static TSLog getTSLog(){
        TSLog tsLog = tsLogCollection.get();

        if(tsLog == null){
            tsLog = new TSLog(Thread.currentThread().getName()+"-log.txt");
            tsLogCollection.set(tsLog);
        }
        return tsLog;
    }

}

class ClientThread extends Thread{
    public ClientThread(String name){
        super(name);
    }

    @Override
    public void run(){
        System.out.println(getName()+" BEGIN");
        for(int i=0;i<10;i++){
            Log1.println("i ="+i);
        }
        try{
            Thread.sleep(100);
        }catch (InterruptedException e){

        }
        Log1.close();
        System.out.println(getName()+" END");
    }
}

public class Test02 {
    public static void main(String[] args) {
        new ClientThread("Alice").start();
        new ClientThread("Bobby").start();
        new ClientThread("Chris").start();
        String s = "32";
    }
}

```

### Copy-On-Write模式

在上一篇文章中我们讲到 Java 里 String 这个类在实现 replace() 方法的时候，并没有更改原字符串里面 value[]数组的内容，而是创建了一个新字符串，这种方法在解决不可变对象的修改问题时经常用到。如果你深入地思考这个方法，你会发现它本质上是一种 Copy-on-Write 方法。所谓 Copy-on-Write，经常被缩写为 COW 或者 CoW，顾名思义就是写时复制。CopyOnWriteArrayList 和 CopyOnWriteArraySet 这两个 Copy-on-Write 容器，它们背后的设计思想就是 Copy-on-Write；通过 Copy-on-Write 这两个容器实现的读操作是无锁的，由于无锁，所以将读操作的性能发挥到了极致。

## 分工-怎么分配任务

### Thread-Per-Message模式 

这个模式是为了分工，将每一个任务分给一个线程执行。比如，网络编程中服务端的实现，来一个请求给一个线程处理。不过这样有点耗线程资源，可以改成线程池。

```java
package ThreadPerMessage;

class Host{
    private final Helper helper = new Helper();

    public void request(final int count,final char c){
        System.out.println(" request("+count+", "+c+") BEGIN");
        new Thread(()->{
                helper.handle(count,c);

        }).start();
        System.out.println(" request("+count+", "+c+") END");
    }
}

class Helper{
    public void handle(int count,char c){
        System.out.println(" handle("+count+", "+c+") BEGIN");
        for(int i=0;i<count;i++){
            slowly();
            System.out.println(c);
        }
        System.out.println("");
        System.out.println(" handle("+", "+c+" ) END");
    }

    private void slowly(){
        try{
            Thread.sleep(100);
        }catch (InterruptedException e){

        }
    }
    }
public class Test01 {
    public static void main(String[] args) {
        System.out.println("main BEGIN");
        Host host = new Host();
        host.request(10,'A');
        host.request(20,'B');
        host.request(30,'C');
    }
}

```

### Worker-Thread模式

频繁地创建、销毁线程非常影响性能，同时无限制地创建线程还可能导致 OOM。Worker Thread 模式可以类比现实世界里车间的工作模式：车间里的工人，有活儿了，大家一起干，没活儿了就聊聊天等着。Worker Thread 模式中 Worker Thread 对应到现实世界里，其实指的就是车间里的工人。不过这里需要注意的是，车间里的工人数量往往是确定的。很容易就能想到用阻塞队列做任务池，然后创建固定数量的线程消费阻塞队列中的任务。其实你仔细想会发现，这个方案就是 Java 语言提供的线程池。

下面就是Worker-Thread模式的示意图，可以看到，Client的puts request操作，像我们向线程池提交任务，而Worker像内置创建好的线程从Channel拿线程执行任务。

![](F:/学习资料/Nodes/Java基础/多线程/resources/WorkerThread模式.PNG)

```java
package WorkerThread;


class Request{
    private final String name;
    private final int number;
    private static  final Random random = new Random();

    public Request(String name,int number){
        this.name = name;
        this.number = number;
    }

    public void execute(){
        System.out.println(Thread.currentThread().getName()+" executes "+this);
        try{
            Thread.sleep(random.nextInt(1000));
        }catch (InterruptedException e){

        }
    }

    public String toString(){
        return "[ Request from "+name +"No."+number+" ]";
    }
}

class Channel{
    private static final int MAX_REQUEST = 100;
    private final Request[] requestQueue;
    private int tail;
    private int head;
    private int count;

    private final WorkerThread[] threadPool;

    public Channel(int threads){
        this.requestQueue = new Request[MAX_REQUEST];
        this.head = 0;
        this.tail = 0;
        this.count = 0;
        threadPool = new WorkerThread[threads];
        for(int i=0;i<threadPool.length;i++){
            threadPool[i] = new WorkerThread("Worker-"+i,this);
        }
    }

    public void startWorkers(){
        for(int i=0;i<threadPool.length;i++){
            threadPool[i].start();
        }
    }

    public synchronized void putRequest(Request request){
        while(count>=requestQueue.length){
            try{
                wait();
            }catch (InterruptedException e){

            }
        }
        requestQueue[tail] =request;
        tail = (tail+1)%requestQueue.length;
        count++;
        notifyAll();
    }

    public synchronized Request takeRequest(){
        while(count<=0){
            try{
                wait();
            }catch (InterruptedException e){

            }
        }
        Request request = requestQueue[head];
        head = (head+1)%requestQueue.length;
        count--;
        notifyAll();
        return request;
    }
}
class ClientThread extends Thread{
    private final Channel channel;
    private static final Random random = new Random();

    public ClientThread(String name, Channel channel){
        super(name);
        this.channel = channel;
    }

    @Override
    public void run(){
        try{
            for(int i=0;true;i++){
                Request request = new Request(getName(),i);
                channel.putRequest(request);
                Thread.sleep(random.nextInt(1000));
            }
        }catch (InterruptedException e){

        }
    }
}

class WorkerThread extends Thread{
    private final Channel channel;
    public WorkerThread(String name, Channel channel){
        super(name);
        this.channel = channel;
    }

    @Override
    public void run(){
        while(true){
            Request request = channel.takeRequest();
            request.execute();
        }
    }

}
public class Test01 {
    public static void main(String[] args) {
        Channel channel = new Channel(5);
        channel.startWorkers();
        new ClientThread("Alice",channel).start();
        new ClientThread("Bobby",channel).start();
        new ClientThread("Chris",channel).start();

    }
}

```



### Guarded Suspension

- 一个线程等待另一个线程执行结果

- 有一个结果需要从线程传递到另一个线程，让他们关联同一个GuardedObject

- 如果有结果不断从一个线程到另一个线程可以使用此消息队列

- JDK中join的实现，Future的实现。

  ![](F:/学习资料/Nodes/Java基础/多线程/resources/GuardedSuspension.PNG)

```java
class GuardedObject {
     private Object response;
     private final Object lock = new Object();
    
     public Object get() {
        synchronized (lock) {
            // 条件不满足则等待
            while (response == null) {
                try {
                	lock.wait();
                } catch (InterruptedException e) {
               		e.printStackTrace();
                } 
            }
            return response; 
        }
     }
     public void complete(Object response) {
        synchronized (lock) {
            // 条件满足，通知等待线程
            this.response = response;
            lock.notifyAll();
        }
     }
}
```

### Balking 模式

Balking模式用在一个线程发现另一个线程或者本线程已经做了某一件相同的事情，那么本线程就无需再做了，直接结束返回。

```java
public class MonitorService {
     // 用来表示是否已经有线程已经在执行启动了
     private volatile boolean starting;
    
     public void start() {
         log.info("尝试启动监控线程...");
         synchronized (this) {
             if (starting) {
             return;
       		 }
             starting = true;
         }

        // 真正启动监控线程...
     }
}
```

### Two-Phase Termination模式

如何优雅的暂停线程

![](F:/学习资料/Nodes/Java基础/多线程/resources/Two-Phase Termination.PNG)

```java
class TPTInterrupt {
     private Thread thread;
    
     public void start(){
         thread = new Thread(() -> {
             while(true) {
            	 Thread current = Thread.currentThread();
                 if(current.isInterrupted()) {
                     log.debug("料理后事");
                     break;
                 }
                     try {
                     Thread.sleep(1000);
                     log.debug("将结果保存");
           	    } catch (InterruptedException e) {
            	     current.interrupt();
             }
             // 执行监控操作 
         }
     },"监控线程");
         
     	thread.start();
     }
    
    
     public void stop() {
    	 thread.interrupt();
     }
}
```

### Producer-consumer

![](F:/学习资料/Nodes/Java基础/多线程/resources/producer-consumer.PNG)

```java
package ProducerConsumer;

class MakerThread extends Thread{
    private final Random random;
    private final Table table;
    private static int id =0;

    public MakerThread(String name,Table table,long seed){
        super(name);
        this.table = table;
        this.random = new Random(seed);
    }

    @Override
    public void run(){
        try {
            while (true) {
                Thread.sleep(random.nextInt(1000));
                String cake = "[Cake No."+nextId()+" by "+getName()+" ]";
                table.put(cake);
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    private static synchronized int nextId(){
        return id++;
    }
}

class EaterThread extends Thread{
    private final Random random;
    private final Table table;

    public EaterThread(String name,Table table,long seed){
        super(name);
        this.table = table;
        this.random = new Random(seed);
    }

    @Override
    public void run(){
        try{
            while(true){
                String cake = table.take();
                Thread.sleep(random.nextInt(1000));
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

class Table{
    private final String [] buffer;
    private int tail;
    private int head;
    private int count;

    public Table(int count){
        this.buffer = new String[count];
        this.head = 0;
        this.tail = 0;
        this.count = 0;
    }

    public synchronized void put(String cake) throws InterruptedException {
        System.out.println(Thread.currentThread().getName()+" puts "+cake);
        while(count>=buffer.length){
            wait();
        }
        buffer[tail]=cake;
        tail=(tail+1)%buffer.length;
        count++;
        notifyAll();
    }

    public synchronized String take() throws InterruptedException {
        while (count<=0){
            wait();
        }
        String cake = buffer[head];
        head = (head+1)%buffer.length;
        count--;
        notifyAll();
        System.out.println(Thread.currentThread().getName()+" takes "+cake);
        return cake;
    }
}
public class Test01 {
    public static void main(String[] args) {
        Table table = new Table(3);
        new MakerThread("MakerThread-1",table,31415).start();
        new MakerThread("MakerThread-2",table,92653).start();
        new MakerThread("MakerThread-3",table,58979).start();
        new EaterThread("EaterThread-1",table,32384).start();
        new EaterThread("EaterThread-2",table,62643).start();
        new EaterThread("EaterThread-3",table,38327).start();
    }
}

```

### Future模式

Future的意思是未来，期货。假设有一个方法需要花费很长时间才能获取运行结果。那么与其一直等待结果，不如先拿一张提货单子。获取提货单并不耗费时间。

![](F:/学习资料/Nodes/Java基础/多线程/resources/Future模式.PNG)

```java
package Future;

import javax.swing.*;

interface Data {
    public abstract String getContent();
}

class RealData implements Data {
    private final String content;

    public RealData(int count, char c) {
        System.out.println(" making RealData(" + count + ", " + c + ") BEGIN");
        char[] buffer = new char[count];
        for (int i = 0; i < count; i++) {
            buffer[i] = c;
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {

            }
        }
        System.out.println(" making RealData(" + count + ", " + c + ") END");
        this.content = new String(buffer);
    }

    @Override
    public String getContent() {
        return content;
    }
}

class FutureData implements Data {
    private RealData realData = null;
    private boolean ready = false;

    public synchronized void setRealData(RealData realData){
        if(ready){
            return;
        }
        this.realData = realData;
        this.ready = true;
        notifyAll();
    }


    @Override
    public synchronized String getContent() {
        while(!ready){
            try{
                wait();
            }catch (InterruptedException e){

            }
        }
        return realData.getContent();
    }
}

class Host {
    public Data request(final int count, final char c) {
        System.out.println("request("+count+", "+c+") BEGIN");

        final FutureData future = new FutureData();

        new Thread(){
            public void run(){
                RealData realData = new RealData(count,c);
                future.setRealData(realData);
            }
        }.start();
        return future;
    }
}

public class Test01 {
    public static void main(String[] args) {
        System.out.println("main BEGIN");
        Host host = new Host();
        Data data1 = host.request(10,'A');
        Data data2 = host.request(20,'B');
        Data data3 = host.request(30,'C');
        System.out.println("main otherJob BEGIN");
        try{
            Thread.sleep(2000);
        }catch (InterruptedException e){

        }
        System.out.println("main otherJob END");

        System.out.println("data1 ="+data1.getContent());
        System.out.println("data2 ="+data2.getContent());
        System.out.println("data3 ="+data3.getContent());
        System.out.println("main END");
    }
}
```

## 单例模式

```java
/*
 	双重检查的原因
 	synchronized里面的代码已经能保证安全性了，访问的时候加类锁，一次只有一个线程创建变量。但是每次访问都要加锁，不能保证性能。
 	为了不加锁在外面判断一下，如果创建了对象，就不进入同步代码块，否则就进入同步代码块。但是由于synchronized里面的指令重排序，INSTANCE又暴露在外面导致会出现问题。
*/

public final class Singleton {
     private Singleton() { }
     private static Singleton INSTANCE = null;
     
     public static Singleton getInstance() { 
         if(INSTANCE == null) { // t2
             // 首次访问会同步，而之后的使用没有 synchronized
             synchronized(Singleton.class) {
                 if (INSTANCE == null) { // t1
                     INSTANCE = new Singleton();
                 } 
             }
         }
         return INSTANCE;
     }
}
```

```
0: getstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton;
3: ifnonnull 37
6: ldc #3 // class cn/itcast/n5/Singleton
8: dup
9: astore_0
10: monitorenter
11: getstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton;
14: ifnonnull 27
17: new #3 // class cn/itcast/n5/Singleton
20: dup
21: invokespecial #4 // Method "<init>":()V
24: putstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton;
27: aload_0
28: monitorexit
29: goto 37
32: astore_1
33: aload_0
34: monitorexit
35: aload_1
36: athrow
37: getstatic #2 // Field INSTANCE:Lcn/itcast/n5/Singleton;
40: aretu
```

- 17 表示创建对象，将对象引用入栈            // new Singleton

- 20 表示复制一份对象引用                         // 引用地址

- 21 表示利用一个对象引用，调用构造方法

- 24 表示利用一个对象引用，赋值给 static INSTANCE

也许 jvm 会优化为：先执行 24，再执行 21。如果两个线程 t1，t2 按如下时间序列执行：

这时 t1 还未完全将构造方法执行完毕，如果在构造方法中要执行很多初始化操作，那么 t2 拿到的是将是一个未初

始化完毕的单例，对 INSTANCE 使用 volatile 修饰即可，可以禁用指令重排，但要注意在 JDK 5 以上的版本的 volatile 才会真正有效

![](F:/学习资料/Nodes/Java基础/多线程/resources/单例模式.PNG)

