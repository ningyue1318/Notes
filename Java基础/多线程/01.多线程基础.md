## 线程基础

### 创建和运行线程

异步调用：

需要等待结果返回，才能继续运行的就是同步。

不需要等待结果返回，就能继续运行的就是异步。

```java
//通过继承的方式，来重写run方法
class  MyThread extends Thread{
    @Override
    public void run() {
        for(int i=0;i<100;i++){
            if(i%2==0){
                System.out.println(i);
            }
        }
    }
}

//匿名类的方式比较合适
Thread thread = new Thread(){
            @Override
            public void run() {
                for(int i=0;i<100;i++){
                    if(i%2==0){
                        System.out.println(i);
                    }
                }
            }
        };
        thread.start();

//实现接口的方式
Runnable r = new Runnable() {
         @Override
         public void run() {
             for(int i=0;i<100;i++){
                 if(i%2==0){
                     System.out.println(i);
                 }
             }
         }
     } ;
     Thread thread = new Thread(r);
     thread.start();

//Lambda表达式
    Thread thread = new Thread(()->{
         for(int i=0;i<100;i++){
             if(i%2==0){
                 System.out.println(i);
             }
         }
     });
     thread.start();

```

Thread和Runnable的关系

- 第一种是把线程和任务合并在了一起，第二种是线程和任务分开了
- 用Runnable更容易和线程池等高级API配合
- 用Runnable让任务类脱离了Thread的继承体系，更灵活。

| 方法名           | static | 功能说明                                           | 注意                                                         |
| ---------------- | ------ | -------------------------------------------------- | ------------------------------------------------------------ |
| start()          |        | 启动新县城，在新的线程中运行run方法                |                                                              |
| run()            |        | 新线程启动后会调用该方法                           |                                                              |
| join()           |        | 等待线程运行结束                                   |                                                              |
| join(long n)     |        | 等待线程运行结束，最多等待n毫秒                    |                                                              |
| getId()          |        | 获取线程长整型id                                   | id唯一                                                       |
| getName()        |        | 获取线程名                                         |                                                              |
| setName(String)  |        | 修改线程名                                         |                                                              |
| getPriority()    |        | 获取线程优先级                                     |                                                              |
| setPriority(int) |        | 修改线程优先级                                     | java中规定线程优先级是1-10的整数，较大优先级能提高该线程被CPU调度的几率 |
| getState()       |        | 获取线程状态                                       | java中线程状态用6个enum表示，分别为NEW，RUNNABLE，BLOCKED，WAITING，TIMED_WAITING，TERMINATED |
| isInterrupted()  |        | 判断是否被打断                                     | 不会清除打断标记                                             |
| isAlive()        |        | 线程是否存活                                       |                                                              |
| interrupte()     |        | 打断线程                                           | 如果被打断的线程正在sleep,wait,join会导致线程抛出InterruptedExceptioon，并清除打断标记，如果打断正在运行的线程，则会设置打断标记 |
| interrupted()    | static | 判断当前线程是否被打断                             | 会清除打断标记                                               |
| currentThread()  | static | 获取当前正在执行的线程                             |                                                              |
| Sleep(long n)    | static | 让当前执行的线程休眠n毫秒，休眠时让出cpu给其他线程 |                                                              |
| yield()          | static | 提示线程调度器让出当前线程对CPU的使用              |                                                              |

- 不调用start方法，直接调用run方法也能执行，不过此时的run方法相当于普通方法，不会开辟线程。
- start方法不能被调用两次，调用第二次的时候，会抛出ILIegalThreadStateException异常

### 线程运行状态

![](resources/线程状态图.png)

- BLOCKED，WAITING，TIMED_WAITING是线程休眠状态的三种原因

- RUNNABLE->BLOCKED,线程synchronized锁导致
- RUNNABLE->WAITING：
  1. 获synchronized隐式锁线程，调用Object.wait()方法
  2. 调用Thread.join()方法
  3. 调用LockSupport.park()方法

- RUNNABLE->TIMED_WAITING的状态转换
  1. Thread.sleep(long millis)方法
  2. 获synchronized隐式锁线程，调用Object.wait(long timeout)方法
  3. 调用带超时参数的 Thread.join(long millis) 方法
  4. 调用带超时参数的 LockSupport.parkNanos(Object blocker, long deadline) 方法；
  5. 调用带超时参数的 LockSupport.parkUntil(long deadline) 方法。

- NEW ->RUNNABLE刚创建出来的Thread对象就是NEW状态，调用start方法进入RUNNABLE状态

- RUNNABLE->TERMINATED:线程执行完run方法就自动跳到终止状态。


Q1:stop方法为什么被弃用？

​     stop会直接暴力的杀死线程，没有善后工作。如果线程持有ReentrantLock锁，没有机会调用unlock释放锁。

interrupt()方法通知线程执行后续操作。

​     如果A处在WAITING，TIMED_WAITING,调用A的interrupt()方法会使线程A回到RUNNABLE状态。同时触发InterruptedException异常。

​     如果A处在RUNNABLE状态，则需要调用isInterrupted()方法来判断是不是自己被中断了,两阶段终止。

Q2：join方法的实现原理，等待A线程结束，就A.join();

```java
public final synchronized void join(long millis)
    throws InterruptedException {
        long base = System.currentTimeMillis();
        long now = 0;

        if (millis < 0) {                                   
            throw new IllegalArgumentException("timeout value is negative");
        } 

        if (millis == 0) { 
            while (isAlive()) {                              //活着就不断的等待
                wait(0);
            }
        } else {
            while (isAlive()) {                             //等待millis秒，超出时间就不等了，或者没到时间，就结束了
                long delay = millis - now;
                if (delay <= 0) {                           //防止虚假唤醒
                    break;
                }
                wait(delay);                                
                now = System.currentTimeMillis() - base;
            }
        }
    }
```

烧水泡茶的例子

```java
      Thread a = new Thread(()->{
           System.out.println("洗水壶");
           try {
               Thread.sleep(1000);
               System.out.println("烧开水");
               Thread.sleep(5000);
           } catch (InterruptedException e) {
               e.printStackTrace();
           }
       });

       Thread b = new Thread(()->{
           System.out.println("洗茶壶");
           try {
               Thread.sleep(1000);
               System.out.println("洗茶杯");
               Thread.sleep(2000);
               a.join();
               System.out.println("泡茶");
               Thread.sleep(1000);
           } catch (InterruptedException e) {
               e.printStackTrace();
           }
       });

       a.start();
       b.start();
```

### 线程共享的问题及解决方案

```java
      Thread a = new Thread(()->{
           for(int i=0;i<5000;i++){
               counter++;
           }
       },"t1");

       Thread b = new Thread(()->{
          for(int i=0;i<5000;i++){
              counter--;
          }
       },"t2");

       a.start();
       b.start();
       a.join();
       b.join();
       System.out.println(counter);

//结果为69，并不是0
```

解决方法：

- 阻塞式：synchronized，Lock
- 非阻塞式：原子变量

```java
//加锁的解决方案，用原子变量也可以。
   public static int counter = 0;
    public static final Object room = new Object();
    public static void main(String[] args) throws InterruptedException {
       Thread a = new Thread(()->{
           for(int i=0;i<5000;i++){
               synchronized (room) {
                   counter++;
               }
           }
       },"t1");

       Thread b = new Thread(()->{
          for(int i=0;i<5000;i++){
              synchronized (room) {
                  counter--;
              }
          }
       },"t2");

        a.start();
        b.start();
        a.join();
        b.join();
        System.out.println(counter);
```

- synchronized加在普通方法上，锁住的对象是this
- synchronized加在静态方法上，锁住的对象是该类的class对象

### 变量的线程安全分析

Q1：成员变量和静态变量是否安全？

- 如果他们没有共享，则线程安全
- 如果他们被共享了，根据他们的状态是否能改变又分两种情况：
  1. 如果只有读操作，则线程安全
  2.  如果有读写操作，则这段代码是临界区，则需要考虑线程安全。

Q2: 局部变量是否安全？

- 局部变量是线程安全的

- 但是局部变量的引用则未必：

  1. 如果该对象没有逃离方法的作用访问，它是线程安全的

  2. 如果逃离了方法的作用范围，需要考虑线程安全

  ```java
  //线程不安全的例子，因为list在堆上，两个线程同时引用该变量，导致出现错误
  //如果list在method1方法内部，虽然也在堆上，但是会创建两个list，不会出现线程安全问题
  public class Test02 {
      public static void main(String[] args) {
          ThreadUnsafe test = new ThreadUnsafe();
          for(int i=0;i<2;i++){
              new Thread(()->{
                 test.method1(1000);
              }).start();
          }
      }
  }
  
  class ThreadUnsafe{
      ArrayList<String> list = new ArrayList<>();
  
      public void method1(int loopNumber){
          for(int i=0;i<loopNumber;i++){ 
              method2();
              method3();
          }
      }
  
      private void method2(){list.add("1");}
  
      private void method3(){list.remove(0);}
  }
  ```
  
### 常见的线程安全类

- String

- Integer

- StringBuffer

- Random

- Vector

- Hashtable

- java.util.concurrent包下的类。

线程安全是指，多个线程调用同一个实例的某个方法是线程安全的，即单个方法是原子的，但是多个方法的组合不是原子的

## Wait&Notify机制

只有拥有锁对象的调用下面的方法才不会出错，否则会报IllegalMonitorStateException异常

- obj.wait()让进入object监视器的线程到waitSet等待
- obj.notify()让object上正在waitSet等待的线程中挑一个唤醒
- obj.notifyAll()让object上正在waitSet等待的线程全部唤醒

```java
       new Thread(()->{
            System.out.println("t1进入线程");
            synchronized (lock){
                try {
                    lock.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            System.out.println("t1:我运气好，我先走了!");

        },"t1").start();

        new Thread(()->{
            System.out.println("t2进入线程");
            synchronized (lock){
                try {
                    lock.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            System.out.println("t2:我运气好，我先走了!");

        },"t2").start();



        Thread.sleep(2000);
        synchronized (lock){
            System.out.println("看看谁运气好");
            lock.notify();
        }
```

```java
//wait的正确使用方法
synchronized(lock){
	while(条件不满足){    //防止被其他线程叫醒时，条件还没满足。
		lock.wait()
	}
}
```

sleep和wait的区别

1. sleep是Thread的方法，而wait是Object的方法。

2. sleep不需要强制和synchronized配合使用，但wait需要和synchronized一起使用。

3. sleep在睡眠的时候，不会释放对象锁，但是wait在等待的时候会释放锁。

4. 他们的状态都是TIMED_WAITING

   

park和unpark 与wait notify的区别

```java
LockSupport.park()；     //暂停当前线程

LockSupport.unpark();    //恢复某个线程的运行
```

1. wait，notify和notifyAll必须配合Object Monitor一起使用，而park，unpark不必。
2. park&unpark是以线程为单位来阻塞和唤醒线程，而notify只能随机唤醒一个线程，notifyAll是唤醒所有等待的线程，就不那么精确。
3. park&unpark可以先unpark，而wait和notify不能先notify。

## ReentrantLock锁

ReentrantLock锁是可重入锁，可重入是指同一个线程如果首次获得这把锁，那么因为它是这把锁的拥有者，因此有权利再次获得这把锁。

相对于synchronized具备以下特点

- 可中断:lock.lockInterruptibly()方法
- 可设置超时时间：lock.tryLock()方法
- 可设置成公平锁
- 支持多个条件变量
- 得手动加锁和解锁

```java
reentrantLock.lock()
try{
	//临界区
}finally{
	reentrantLock.unlock()
}
```

```java
 //MESA模型的实现，synchronized是简化实现只有一个条件变量，这个实现了有多个条件变量。这样做防止了虚假唤醒。
       Condition condition1 = lock.newCondition();
        Condition condition2 = lock.newCondition();

        lock.lock();

        condition1.await();

        condition1.signal();
```

## 无锁工具-原子类

![](resources\原子类.png)

原子类的实现靠的是CAS操作，下面就是CAS的原理。

```java
//balance是账户余额，amount是要减少的钱
public void withdraw(Integer amount){
    while(true){
        //获得旧值
        int prev = balance.get();
        //balance没被修改的时候，希望的得到的值。
        int next = prev - amount;
        //判断是否发生了修改，发生修改了就重试，没有发生修改就返回true。
        if(balance.compareAndSet(prev,next)){
            break;
        }
    }
}
```

但是CAS会产生ABA问题，线程A想把A变成C，在变的过程中，有线程把A变成了B，又变回了A，但是前面的线程还是能把A修改成C，

可以再加一个版本号，来解决这个问题

synchronized和CAS的区别:

- CAS 是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，重试。

- synchronized 是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想

改，我改完了解开锁，你们才有机会。

CAS效率高的原因：

- 因为没有使用 synchronized，所以线程不会陷入阻塞，没有上下文切换。

- 但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响，自旋需要CPU，适合多核情况。

### 原子整数

```java
AtomicInteger i = new AtomicInteger(0);

// 获取并自增（i = 0, 结果 i = 1, 返回 0），类似于 i++
System.out.println(i.getAndIncrement());

// 自增并获取（i = 1, 结果 i = 2, 返回 2），类似于 ++i
System.out.println(i.incrementAndGet());

// 自减并获取（i = 2, 结果 i = 1, 返回 1），类似于 --i
System.out.println(i.decrementAndGet());

// 获取并自减（i = 1, 结果 i = 0, 返回 1），类似于 i--
System.out.println(i.getAndDecrement());
```

### 原子引用

AtomicStampedReference- 可以记录修改的版本号

AtomicMarkableReference-记录有没有被修改过

都能解决ABA问题。

## 不可变对象

## 线程池

线程池的好处：

- 降低资源消耗，通过重复利用已创建的线程降低线程创建和销毁造成的损耗。
- 提高响应速度，当任务到达时，任务可以不需要等到线程创建就能立即执行。
- 提高线程的可管理性。